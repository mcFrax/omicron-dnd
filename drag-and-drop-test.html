<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>JS Test</title>
    <style>
        .scroll-container {
            width: 400px;
            height: 80vh;
            overflow: hidden scroll;
            background: aliceblue;
        }
        .drag-container {
            position: relative;
            width: 100%;
            overflow: hidden;
            padding: 10px;
        }
        .item {
            position: relative; /* for z-index to work */
            z-index: 2; /* above placeholder */
            padding: 10px;
            margin: 8px;
            font-size: 2rem;
            font-weight: bold;
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
            user-select: none;
            cursor: pointer;
        }
        .item.drag-active-item {
            visibility: hidden;
            pointer-events: none;
        }
        .item.drag-float-item {
            position: fixed; /* This is required to escape from overflow rules. */
            left: 0;
            top: 0;
            z-index: 10000000;
        }
        .blue {
            background: cornflowerblue;
        }
        .purple {
            background: mediumpurple;
        }
        .pink {
            background: deeppink;
        }
        .red {
            background: tomato;
        }
        .green {
            background: lightgreen;
        }
        .drag-placeholder {
            position: absolute;
            left: 18px; /* padding + item's margin */
            top: 0;
            width: calc(100% - 38px);
            height: 20px;
            z-index: 1;
            background: lightgray;
            user-select: none;
            pointer-events: none;
            visibility: hidden;
        }
    </style>
</head>
<body>
    <h1>Drag&drop test</h1>
    <div class="scroll-container">
        <div class="drag-container">
            <div class="item blue">
                ITEM
            </div>
            <div class="item purple">
                ITEM
            </div>
            <div class="item pink">
                ITEM
            </div>
            <div class="item red">
                ITEM
            </div>
            <div class="drag-placeholder"></div>
        </div>
    </div>
    <script>
        let $ = (s) => document.querySelector(s);
        let $$ = (s) => Array.from(document.querySelectorAll(s));

        const placeholderHeight = 20;
        const animMs = 100;

        let fromEl = null;
        let toEl = null;
        let activeEl = null;
        let floatEl = null;
        let placeholderEl = null;
        // TODO: current semantic is actually spliceIndex+insertIndex. It would
        // be likely better to change it to actually oldIndex and newIndex.
        // Or at least rename them to reflect the actual semantic.
        let oldIndex = 0;
        let newIndex = 0;
        let activeToPlaceholderOffset = 0;
        let activeToNothingOffset = 0;
        let nothingToPlaceholderOffset = 0;
        let xCursorOffset = 0;
        let yCursorOffset = 0;
        let xLast = 0;
        let yLast = 0;
        let xDragClientPos = 0;
        let yDragClientPos = 0;
        let yStartNoMoveZone = 0; // When cursor is between yStartNoMoveZone
        let yEndNoMoveZone = 0;   // and yEndNoMoveZone nothing will happen.
        let animFrameRequestId = 0; // 0 is never used as actual id.
        let yDirection = -1;

        let anims = [];
        let animsByElem = new Map();

        function initDragContainer(containerEl) {
            containerEl.addEventListener('mousedown', noDrag_container_MouseDown);
            containerEl.addEventListener('mouseenter', anyState_container_MouseEnter);
        }
        function noDrag_container_MouseDown(event) {
            // assert(dragEl === null);  // Not true if we add nested containers.
            if (event.button !== 0) {
                return;
            }
            activeEl = getItemFromContainerEvent(event);
            if (!activeEl) {
                return;
            }
            toEl = fromEl = event.currentTarget;
            placeholderEl = fromEl.lastElementChild;
            // We don't need to remove it from other elements, as there will
            // be no mousedown event until we are done.
            fromEl.removeEventListener('mousedown', noDrag_container_MouseDown);
            window.addEventListener('mousemove', drag_window_MouseMove, true);
            window.addEventListener('mouseup', drag_window_MouseUp, true);

            xLast = event.clientX;
            yLast = event.clientY;
            let activeElRect = activeEl.getClientRects()[0];
            xCursorOffset = activeElRect.left - event.clientX;
            yCursorOffset = activeElRect.top - event.clientY;
            xDragClientPos = xLast + xCursorOffset;
            yDragClientPos = yLast + yCursorOffset;

            yStartNoMoveZone = activeElRect.top - 10;
            // We need to compute the end from the top, and use placeholder's
            // height instead of the element's height.
            yEndNoMoveZone = activeElRect.top + 30;

            const currentItemWidth = getComputedStyle(activeEl).width;
            const dragElHeight = activeEl.offsetHeight;

            activeToPlaceholderOffset = placeholderEl.offsetHeight - dragElHeight;
            activeToNothingOffset = -dragElHeight - 8;
            nothingToPlaceholderOffset = placeholderEl.offsetHeight + 8;

            placeholderEl.style.transform = `translateY(${activeEl.offsetTop}px)`;
            placeholderEl.style.visibility = 'visible';

            floatEl = activeEl.cloneNode(true);
            floatEl.classList.add('drag-float-item');
            floatEl.style.width = currentItemWidth;
            floatEl.style.transform = `translate(${xDragClientPos}px,${yDragClientPos}px)`;
            fromEl.appendChild(floatEl);


            activeEl.classList.add('drag-active-item');

            // Note: this is a string with px.

            let childrenArray = Array.from(fromEl.children);
            newIndex = oldIndex = childrenArray.indexOf(activeEl);
            // Skip 2 elements at the end: the placeholder and floatEl.
            let itemsAfter = childrenArray.slice(oldIndex + 1, -2);
            Anim.start(fromEl, itemsAfter, activeToPlaceholderOffset, animMs);
        }
        function drag_window_MouseMove(event) {
            event.stopPropagation();
            event.preventDefault();

            // assert((event.buttons & 1) === 1)

            // Update the mouse position.
            if (event.movementY !== 0) {
                yDirection = event.movementY > 0 ? 1 : -1;
            }
            xLast = event.clientX;
            yLast = event.clientY;
            xDragClientPos = xLast + xCursorOffset;
            yDragClientPos = yLast + yCursorOffset;

            // Update the position of dragEl before the next frame.
            if (!animFrameRequestId) {
                animFrameRequestId = requestAnimationFrame(animationFrame);
            }

            // TODO: extract the logic below to the common handling for mousemove and mouseenter.
            // This will include replacing newIndex with a "baseIndex" or something,
            // and the yStartNoMoveZone/yEndNoMoveZone must be updated accordingly.
            // Perhaps the toEl should be replaced with a newToEl as argument
            // to avoid a brittle global variable dependency.

            let updatedNewIndex = newIndex;

            let wiggleZoneSize = 0.7;
            let snapMargin = (1 - wiggleZoneSize) / 2;
            let bottomSnapPart = yDirection === -1 ? snapMargin : (1 - snapMargin);
            let mouseY = event.clientY;
            let itemsInContainer = toEl.children.length - ((toEl === fromEl) ? 2 : 1);
            if (mouseY < yStartNoMoveZone && newIndex !== 0) {
                // Correct for the fact that if we dragged the element down from
                // its place, some elements above it are shifted from their
                // offset position.
                let offsetCorrection = toEl === fromEl ? activeToNothingOffset : 0;
                updatedNewIndex = 0;
                // We may look up one extra element at the start, but that is not an issue.
                let iterationStart = Math.min(newIndex, itemsInContainer - 1);
                for (let i = iterationStart; i >= 0; --i) {
                    let otherEl = toEl.children[i];
                    if (otherEl === activeEl) continue;
                    if (i < oldIndex) {
                        // We could check for (toEl === fromEl) here, but the
                        // value is going to be 0 anyway.
                        offsetCorrection = 0;
                    }
                    let otherTop = otherEl.offsetTop + offsetCorrection;
                    let otherHeight = otherEl.offsetHeight;
                    if (mouseY > otherTop + bottomSnapPart * otherHeight) {
                        // Insert activeEl after otherEl.
                        if (toEl === fromEl && i > oldIndex) {
                            // Special new case. otherEl will be moved up
                            // and end up with index i-1, so inserting after
                            // it means we will end up with index i.
                            updatedNewIndex = i;
                        } else {
                            updatedNewIndex = i + 1;
                        }
                        break;
                    }
                }
            }
            if (mouseY > yEndNoMoveZone) {
                let offsetCorrection = nothingToPlaceholderOffset;
                // Set to the highest possible value - in case we are at the very
                // bottom of the container.
                updatedNewIndex = (toEl === fromEl) ? itemsInContainer - 1 : itemsInContainer;
                // We may look up one extra element at the start, but that is not an issue.
                for (let i = newIndex; i < itemsInContainer; ++i) {
                    let otherEl = toEl.children[i];
                    if (otherEl === activeEl) continue;  // May still happen.
                    if (i > oldIndex && toEl === fromEl) {
                        offsetCorrection = activeToPlaceholderOffset;
                    }
                    let otherTop = otherEl.offsetTop + offsetCorrection;
                    let otherHeight = otherEl.offsetHeight;
                    if (mouseY < otherTop + bottomSnapPart * otherHeight) {
                        // Insert activeEl before otherEl.
                        if (toEl === fromEl && i > oldIndex) {
                            // Special new case. otherEl won't be bumped to i+1
                            // but instead back to i-th position when we
                            // re-insert activeEl, so the inserting splice
                            // will be at position i-1, not i.
                            updatedNewIndex = i - 1;
                        } else {
                            updatedNewIndex = i;
                        }
                        break;
                    }
                }
            }
            if (updatedNewIndex != newIndex) {
                let previousIndex = newIndex;
                newIndex = updatedNewIndex;
                animateMoveInsideContainer(toEl, previousIndex, updatedNewIndex);
            }
        }

        function animateMoveInsideContainer(containerEl, previousIndex, newNewIndex) {
            console.log('moveInsideContainer', newNewIndex);


            // There are 4 groups of elements, adjusted by different offsets:
            //
            // 1. no offset
            // All elements before oldIndex (in fromEl) or newIndex
            // (in containerEl).
            // When fromEl === containerEl, both conditions are required.
            //
            // 2. activeToPlaceholderOffset
            // Elements in fromEl with index after max(newIndex, oldIndex).
            //
            // 3. activeToNothingOffset
            // Elements in fromEl that are after oldIndex, except those
            // after newIndex when fromEl === containerEl.
            //
            // 4. nothingToPlaceholderOffset
            // All elements after newIndex except those in fromEl that are also
            // after oldIndex.
            //
            // I though that I'd do something smart to change the elements
            // that are affected in groups, but no I'm thinking I'll go over
            // all potentially effected elements and run the above logic for
            // each of them.

            // shadow newIndex to avoid using it accidentally
            let newIndex = 'DEATH AND DESTRUCTION!';

            let inFromEl = (fromEl === containerEl);
            let affectedStart = Math.min(newNewIndex, previousIndex);
            let affectedEnd = Math.max(newNewIndex, previousIndex);

            // Note: we are using actual oldIndex below, not previousIndex.
            // This is because we have to deal with activeEl affecting offsets,
            // even though it's not visible.
            // Previous index doesn't matter any more here, it was only
            // for determining the affected range.
            for (let i = affectedStart; i < affectedEnd; ++i) {
                let otherEl = containerEl.children[i];
                if (otherEl === activeEl) continue;

                let aboveNew = i >= newNewIndex;
                let aboveOld = inFromEl && i >= oldIndex;

                if (aboveNew && aboveOld) {
                    Anim.start(containerEl, [otherEl], activeToPlaceholderOffset, animMs);
                }
            }
        }

        function drag_window_MouseUp(event) {
            if (event.button !== 0) {
                return;
            }

            floatEl.remove();

            // Although there may be many elements moving, the only group that
            // is not going into the right place yet are the elements after the
            // inserted/reverted element.
            let childrenArray = Array.from(fromEl.children);
            let itemsAfter = childrenArray.slice(oldIndex + 1, -1);
            Anim.start(fromEl, itemsAfter, 0, animMs);

            activeEl.classList.remove('drag-active-item');
            placeholderEl.style.visibility = 'hidden';
            placeholderEl.transform = null;

            fromEl.addEventListener('mousedown', noDrag_container_MouseDown);
            window.removeEventListener('mousemove', drag_window_MouseMove, true);
            window.removeEventListener('mouseup', drag_window_MouseUp, true);

            activeEl = null;
            floatEl = null;
            fromEl = null;
            toEl = null;
            placeholderEl = null;
            oldIndex = newIndex = 0;
            yDirection = -1;
        }

        function anyState_container_MouseEnter(event) {
            if (!fromEl) {
                // Not dragging anything, so nothing to do.
                return;
            }
            if (event.currentTarget === toEl) {
                // Already in this container, nothing to do.
                return;
            }
            // TODO: cleanup in toEl.
            toEl = event.currentTarget;
            // TODO: set the placeholder and animate the elements below it.
        }

        function animationFrame(timestamp) {
            animFrameRequestId = 0;  // Allow scheduling for the next frame.
            if (floatEl) {
                // TODO: adjust for scroll or other changes of the base.
                floatEl.style.transform = `translate(${xDragClientPos}px,${yDragClientPos}px)`;
            }
            let needsNextFrame = false;
            // Iterate backwards to allow simple removal.
            for (let i = anims.length - 1; i >= 0; --i) {
                if (anims[i].animationFrame(timestamp)) {
                    needsNextFrame = true;
                } else {
                    for (let elem of anims[i].elems) {
                        animsByElem.delete(elem);
                    }
                    anims.splice(i, 1);
                }
            }
            if (needsNextFrame) {
                animFrameRequestId = requestAnimationFrame(animationFrame);
            }
        }


        // Utils.

        class Anim {
            static start(parentEl, elems, targetYTranslation, durationMs, startYTranslation) {
                // How the actual, visible position differs from offsetTop.
                if (typeof startYTranslation === 'undefined') {
                    // TODO: Group the elements with the same initial translation.
                    // Round the initial translation to avoid sub-pixel differences.
                    // Alternatively work it around so that we _know_ all elements
                    // have the same starting transform - generating all these rects
                    // is a lot of useless computation and allocation.
                    let parentRect = parentEl.getClientRects()[0];
                    for (let elem of elems) {
                        let elemRect = elem.getClientRects()[0];
                        startYTranslation = (elemRect.top - parentRect.top) - elem.offsetTop;
                        if (startYTranslation !== targetYTranslation) {
                            Anim.add(elem, new Anim(parentEl, [elem], startYTranslation, targetYTranslation, durationMs));
                        }
                    }
                } else {
                    // Immediately make sure that the elements are where they are supposed to start.
                    let transformString = `translateY(${startYTranslation}px)`;
                    for (let elem of elems) {
                        elem.style.transform = transformString;
                        Anim.add(elem, new Anim(parentEl, [elem], startYTranslation, targetYTranslation, durationMs));
                    }
                }
                if (!animFrameRequestId) {
                    animFrameRequestId = requestAnimationFrame(animationFrame);
                }
            }

            /* private */ static add(elem, anim) {
                // Replace any old anim for this elem.
                let previousAnim = animsByElem.get(elem);
                if (previousAnim) {
                    anims.splice(anims.indexOf(previousAnim), 1);
                }
                anims.push(anim);
                animsByElem.set(elem, anim);
            }

            /* private */ constructor(parentEl, elems, startYTranslation, targetYTranslation, durationMs) {
                // assert(elems.length);
                this.parentEl = parentEl;
                this.elems = elems;
                this.startYTranslation = startYTranslation;
                this.targetYTranslation = targetYTranslation;
                this.durationMs = durationMs;
                this.startTime = null;  // Will be filled in in the animation frame.
                this.endTime = null;
            }

            // Will return true if the next frame should be requested.
            animationFrame(timestamp) {
                if (!this.startTime) {
                    this.startTime = timestamp;
                    this.endTime = timestamp + this.durationMs;
                    return true;  // Do nothing
                }
                let advancementRate =
                    timestamp >= this.endTime ? 1 : (timestamp - this.startTime) / this.durationMs;
                let currentYTranslation =
                    advancementRate * this.targetYTranslation + (1 - advancementRate) * this.startYTranslation;
                let transformString = `translateY(${currentYTranslation}px)`;
                for (let elem of this.elems) {
                    elem.style.transform = transformString;
                }
                return (advancementRate < 1);
            }
        }

        function getItemFromContainerEvent(event) {
            // For now let's just find the element that is directly inside container.
            // We can add a filter for handle on the way if we ever need, check for
            // filter-in and -out classes, but eventually we just want this direct
            // child.
            let containerEl = event.currentTarget;
            let result = null;
            for (let el = event.target; el !== containerEl; el = el.parentElement) {
                result = el;
            }
            // Returns null if the event is directly on the container,
            // or the element was filtered out for any reason.
            if (result && result.classList.contains('item'))
                return result;
            else {
                return null;
            }
        }

        // Init.
        for (let i = 0; i < 800; ++i) {
            let el = document.createElement('div');
            el.classList.add('item');
            el.classList.add('green');
            el.textContent = 'ITEM';
            $('.drag-placeholder').before(el);
        }
        initDragContainer($('.drag-container'));
    </script>
</body>
</html>
