<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>JS Test</title>
    <style>
        .drag-container {
            position: relative;
            width: 400px;
            padding: 10px;
            margin: 40px;
            border: 1px solid black;
        }
        .item {
            position: relative; /* for z-index to work */
            z-index: 2; /* above placeholder */
            padding: 10px;
            margin: 8px;
            font-size: 2rem;
            font-weight: bold;
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
            user-select: none;
            cursor: pointer;
        }
        .item.drag-item {
            z-index: 10000000;
        }
        .blue {
            background: cornflowerblue;
        }
        .purple {
            background: mediumpurple;
        }
        .pink {
            background: deeppink;
        }
        .red {
            background: tomato;
        }
        .green {
            background: lightgreen;
        }
        .drag-placeholder {
            position: absolute;
            left: 18px; /* padding + item's margin */
            top: 0;
            width: calc(100% - 38px);
            height: 20px;
            z-index: 1;
            background: lightgray;
            user-select: none;
            pointer-events: none;
            visibility: hidden;
        }
    </style>
</head>
<body>
    <h1>Drag&drop test</h1>
    <div class="drag-container">
        <div class="item blue">
            ITEM
        </div>
        <div class="item purple">
            ITEM
        </div>
        <div class="item pink">
            ITEM
        </div>
        <div class="item red">
            ITEM
        </div>
        <div class="drag-placeholder"></div>
    </div>
    <script>
        let $ = (s) => document.querySelector(s);
        let $$ = (s) => Array.from(document.querySelectorAll(s));

        const placeholderHeight = 20;

        let fromEl = null;
        let dragEl = null;
        let placeholderEl = null;
        let xBase = 0;
        let yBase = 0;
        let xLast = 0;
        let yLast = 0;
        let xDelta = 0;
        let yDelta = 0;
        let animFrameRequestId = 0; // 0 is never used as actual id.

        let animGroups = [];

        function initDragContainer(containerEl) {
            containerEl.addEventListener('mousedown', noDrag_container_MouseDown);
        }
        function noDrag_container_MouseDown(event) {
            // assert(dragEl === null);  // Not true if we add nested containers.
            if (event.button !== 0) {
                return;
            }
            dragEl = getItemFromContainerEvent(event);
            if (!dragEl) {
                return;
            }
            fromEl = event.currentTarget;
            placeholderEl = fromEl.lastElementChild;
            // We don't need to remove it from other elements, as there will
            // be no mousedown event until we are done.
            fromEl.removeEventListener('mousedown', noDrag_container_MouseDown);
            window.addEventListener('mousemove', drag_window_MouseMove, true);
            window.addEventListener('mouseup', drag_window_MouseUp, true);

            xLast = xBase = event.clientX;
            yLast = yBase = event.clientY;
            xDelta = yDelta = 0;

            dragEl.classList.add('drag-item');
            placeholderEl.style.transform = `translateY(${dragEl.offsetTop}px)`;
            placeholderEl.style.visibility = 'visible';

            let childrenArray = Array.from(fromEl.children);
            let itemsAfter = childrenArray.slice(childrenArray.indexOf(dragEl) + 1, -1);
            AnimGroup.start(fromEl, itemsAfter, placeholderEl.offsetHeight - dragEl.offsetHeight, 200);
        }
        function drag_window_MouseMove(event) {
            event.stopPropagation();
            event.preventDefault();

            // assert((event.buttons & 1) === 1)

            // Update the mouse position.
            xLast = event.clientX;
            yLast = event.clientY;
            xDelta = xLast - xBase;
            yDelta = yLast - yBase;

            // Update the position of dragEl before the next frame.
            if (!animFrameRequestId) {
                animFrameRequestId = requestAnimationFrame(animationFrame);
            }
        }

        function drag_window_MouseUp(event) {
            if (event.button !== 0) {
                return;
            }

            dragEl.style.transform = null;
            dragEl.classList.remove('drag-item');
            placeholderEl.style.visibility = 'hidden';
            placeholderEl.transform = null;

            fromEl.addEventListener('mousedown', noDrag_container_MouseDown);
            window.removeEventListener('mousemove', drag_window_MouseMove, true);
            window.removeEventListener('mouseup', drag_window_MouseUp, true);

            dragEl = null;
            fromEl = null;
            placeholderEl = null;

            // Move elements back.
        }

        function animationFrame(timestamp) {
            animFrameRequestId = 0;  // Allow scheduling for the next frame.
            if (dragEl) {
                // TODO: adjust for scroll or other changes of the base.
                dragEl.style.transform = `translate(${xDelta}px,${yDelta}px)`;
            }
            let needsNextFrame = false;
            // Iterate backwards to allow simple removal.
            for (let i = animGroups.length - 1; i >= 0; --i) {
                if (animGroups[i].animationFrame(timestamp)) {
                    needsNextFrame = true;
                } else {
                    animGroups.splice(i, 1);
                }
            }
            if (needsNextFrame) {
                animFrameRequestId = requestAnimationFrame(animationFrame);
            }
        }


        // Utils.

        class AnimGroup {
            static start(parentEl, elems, targetYTranslation, durationMs) {
                // Assume all the elements have the same starting Y translation,
                // and compute it.
                let parentRect = parentEl.getClientRects()[0];
                let elemRect = elems[0].getClientRects()[0];
                // How the actual, visible position differs from offsetTop.
                let startYTranslation = (elemRect.top - parentRect.top) - elems[0].offsetTop;
                if (startYTranslation === targetYTranslation) {
                    return;
                }
                animGroups.push(new AnimGroup(parentEl, elems, startYTranslation, targetYTranslation, durationMs));
                if (!animFrameRequestId) {
                    animFrameRequestId = requestAnimationFrame(animationFrame);
                }
            }

            /* private */ constructor(parentEl, elems, startYTranslation, targetYTranslation, durationMs) {
                // assert(elems.length);
                this.parentEl = parentEl;
                this.elems = elems;
                this.startYTranslation = startYTranslation;
                this.targetYTranslation = targetYTranslation;
                this.durationMs = durationMs;
                this.startTime = null;  // Will be filled in in the animation frame.
                this.endTime = null;
            }

            // Will return true if the next frame should be requested.
            animationFrame(timestamp) {
                if (!this.startTime) {
                    this.startTime = timestamp;
                    this.endTime = timestamp + this.durationMs;
                    return true;  // Do nothing
                }
                let advancementRate =
                    timestamp >= this.endTime ? 1 : (timestamp - this.startTime) / this.durationMs;
                let currentYTranslation =
                    advancementRate * this.targetYTranslation + (1 - advancementRate) * this.startYTranslation;
                let transformString = `translateY(${currentYTranslation}px)`;
                for (let elem of this.elems) {
                    elem.style.transform = transformString;
                }
                return (advancementRate < 1);
            }
        }

        function getItemFromContainerEvent(event) {
            // For now let's just find the element that is directly inside container.
            // We can add a filter for handle on the way if we ever need, check for
            // filter-in and -out classes, but eventually we just want this direct
            // child.
            let containerEl = event.currentTarget;
            let result = null;
            for (let el = event.target; el !== containerEl; el = el.parentElement) {
                result = el;
            }
            // Returns null if the event is directly on the container,
            // or the element was filtered out for any reason.
            if (result && result.classList.contains('item'))
                return result;
            else {
                return null;
            }
        }

        // Init.
        initDragContainer($('.drag-container'));
    </script>
</body>
</html>
