{"version":3,"file":"omicron-dnd.js","mappings":";;;;;;;;;;;;;;;;;;AAAuC;AACuB;AAClB;AACG;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6CAAS,aAAa,6CAAS,uBAAuB,mDAAe,MAAM,yDAAqB;AACzG;AACA;AACA,2BAA2B,mEAA+B;AAC1D,sCAAsC,gDAAY,GAAG,2EAAuC;AAC5F;AACA,mDAAmD,gDAAY;AAC/D,uBAAuB,2EAA2B;AAClD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA,YAAY,sDAAkB,KAAK,0DAAa,gBAAgB,sDAAkB;AAClF;AACA,wBAAwB,sDAAkB,KAAK,0DAAa;AAC5D,4BAA4B,8DAA0B;AACtD,iBAAiB,wDAAoB;AACrC;AACA;AACA,YAAY,8CAAU,oDAAoD,0CAAM;AAChF;AACA;AACA,YAAY,8CAAU,qDAAqD,0CAAM;AACjF;AACA;AACA,YAAY,8CAAU,gDAAgD,0CAAM;AAC5E;AACA;AACA,YAAY,8CAAU,4BAA4B,0CAAM;AACxD;AACA;AACA;;;;;;;;;;;;;;;;;ACnEO;AACP;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B;AAC5B;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;ACnBoC;AACW;AAC/C;AACA;AACO;AACP;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,6CAAS,aAAa,6CAAS,uBAAuB,qDAAiB;AAC3F,2BAA2B,6CAAS,aAAa,6CAAS,uBAAuB,mDAAe,MAAM,yDAAqB,SAAS,gDAAY;AAChJ,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6CAAS,aAAa,6CAAS,uBAAuB,mDAAe,MAAM,yDAAqB,sBAAsB,gDAAY;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yCAAyC,IAAI;AAC7C,YAAY,6CAAO;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1E+C;AACxC;AACP,SAAS,6CAAS,KAAK,uDAAmB,IAAI,mDAAe,KAAK,qDAAiB;AACnF;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kCAAkC;AAC3B;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;;;;;;;;;;;;;;;ACAP;AACO;AACP;AACA;AACA;AACA,CAAC,4BAA4B;;;;;;;;;;;;;;;;ACLO;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxB8C;AAC9C;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACP,6BAA6B,2DAAW;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1B4C;AACR;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,6CAAS,oBAAoB,8DAA0B,IAAI,sDAAkB,KAAK,0DAAa,oBAAoB,wDAAoB;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,6CAAS,oBAAoB,8DAA0B,IAAI,sDAAkB,KAAK,0DAAa,qBAAqB,wDAAoB;AAChJ;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjB6C;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5HA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnBoC;AACpC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mCAAmC;AACnC;AACO;AACP;AACA;AACA,SAAS,6CAAS;AAClB;AACA;AACA;AACA,kBAAkB,iEAA6B;AAC/C,kBAAkB,iEAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrKA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA,6DAA6D,yBAAyB,kBAAkB,qDAAqD;AAC7J;AACA;AACO;AACA;AACP;AACA;AACA;;;;;;;;;;;;;;;;AC1B+C;AAC/C;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B,QAAQ,6CAAS,IAAI,mDAAe,KAAK,yDAAqB;AAC9D;AACA,QAAQ,qEAAiC,gBAAgB,0DAAsB,CAAC,KAAK,0DAAsB,CAAC,YAAY,0DAAsB,CAAC;AAC/I;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;UCfA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACN4D;AACH;AACD;AACsF;AAClD;AACxD;AACQ;AACW;AACmD;AACpC;AACJ;AACrB;AAC+C;AACvB;AACiB;AACV;AACD;AAC3E;AACA,kBAAkB,6CAAO;AACzB,gBAAgB;AAChB;AACA;AACA,SAAS,6CAAO;AAChB;AACA,uCAAuC,uDAAgB,iBAAiB;AACxE;AACA,SAAS;AACT,KAAK;AACL,IAAI,6DAAe;AACnB,qBAAqB,+DAAqB;AAC1C,sBAAsB,+DAAqB;AAC3C;AACA,IAAI,6DAAe;AACnB;AACA;AACA;AACA;AACA,oBAAoB,6CAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAe;AACvB;AACA;AACA;AACA;AACA,4BAA4B,6DAAmB;AAC/C;AACA;AACA;AACA,QAAQ,6DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAmB;AAC/C;AACA;AACA;AACA,QAAQ,6DAAe;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAe;AACnB,wBAAwB,6DAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oEAAoB;AAC7B;AACA;AACA;AACA;AACA,QAAQ,8CAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6CAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yEAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4EAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qDAAY;AAChB,eAAe,sDAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAgB;AAC9C;AACA,KAAK;AACL;AACA;AACA,SAAS,8CAAS,aAAa,8CAAS,uBAAuB,oDAAe,MAAM,sDAAiB;AACrG,kBAAkB,kDAAa,CAAC,sDA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;AAC1D;AACA;AACA;AACA,sCAAsC,iDAAY,GAAG,4EAAuC;AAC5F;AACA,mDAAmD,iDAAY;AAC/D;AACA;AACA;AACA,qBAAqB,6EAA6B;AAClD,mBAAmB,2EAA2B;AAC9C;AACA;AACA;AACA;AACA,+CAA+C,+DAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA,4BAA4B,uDAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA,4BAA4B,uDAAkB;AAC9C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA,8BAA8B,mCAAmC;AACjE,SAAS,8CAAS,aAAa,8CAAS,uBAAuB,oDAAe,MAAM,0DAAqB;AACzG,kBAAkB,kDAAa,CAAC,0DAAqB;AACrD,YAAY,wCAAwC,EAAE,mDAAc;AACpE,mBAAmB,uDAAkB,KAAK,0DAAa;AACvD;AACA,2BAA2B,oEAA+B;AAC1D;AACA,qBAAqB,6EAA6B;AAClD,mBAAmB,2EAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAS,aAAa,8CAAS,uBAAuB,oDAAe,MAAM,0DAAqB;AACzG,kBAAkB,kDAAa,CAAC,0DAAqB;AACrD;AACA;AACA;AACA,SAAS,8CAAS,aAAa,8CAAS,uB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","sources":["webpack://omicron-dnd/./animate-move.ts","webpack://omicron-dnd/./anims.ts","webpack://omicron-dnd/./click-blocker.ts","webpack://omicron-dnd/./dom-traversal.ts","webpack://omicron-dnd/./event-utils.ts","webpack://omicron-dnd/./expando.ts","webpack://omicron-dnd/./external-types.ts","webpack://omicron-dnd/./forbidden-indices.ts","webpack://omicron-dnd/./hover-tracker.ts","webpack://omicron-dnd/./index-conversions.ts","webpack://omicron-dnd/./invisible-item.ts","webpack://omicron-dnd/./options.ts","webpack://omicron-dnd/./overscroll-behavior.ts","webpack://omicron-dnd/./scrollers.ts","webpack://omicron-dnd/./selection-control.ts","webpack://omicron-dnd/./state.ts","webpack://omicron-dnd/./update-float-el-on-next-frame.ts","webpack://omicron-dnd/webpack/bootstrap","webpack://omicron-dnd/webpack/runtime/define property getters","webpack://omicron-dnd/webpack/runtime/hasOwnProperty shorthand","webpack://omicron-dnd/webpack/runtime/make namespace object","webpack://omicron-dnd/./omicron-main.ts"],"sourcesContent":["import { Anim, animMs } from \"./anims\";\nimport { getItemsInContainerEndIndex } from \"./dom-traversal\";\nimport { DragKind } from \"./external-types\";\nimport { dragState, StateEnum } from \"./state\";\nexport function animateMoveInsideContainer(containerEl, previousEventualIndex, newEventualIndex) {\n    // There are 4 groups of elements, adjusted by different offsets:\n    //\n    // 1. no offset\n    // All elements before oldIndex (in fromEl) or newIndex\n    // (in containerEl).\n    // When fromEl === containerEl, both conditions are required.\n    //\n    // 2. activeToPlaceholderOffset\n    // Elements in fromEl with index after max(newIndex, oldIndex).\n    //\n    // 3. activeToNothingOffset\n    // Elements in fromEl that are after oldIndex, except those\n    // after newIndex when fromEl === containerEl.\n    //\n    // 4. nothingToPlaceholderOffset\n    // All elements after newIndex except those in fromEl that are also\n    // after oldIndex.\n    //\n    // I though that I'd do something smart to change the elements\n    // that are affected in groups, but no I'm thinking I'll go over\n    // all potentially effected elements and run the above logic for\n    // each of them.\n    var _a, _b;\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        return;\n    // TODO: Extract, deduplicate, cache.\n    const activeElHeight = dragState.pickedEl.offsetHeight;\n    const activeToPlaceholderOffset = dragState.to ? dragState.to.placeholderEl.offsetHeight - activeElHeight : 0;\n    const activeToNothingOffset = -activeElHeight - 8;\n    const nothingToPlaceholderOffset = (_b = (_a = dragState.to) === null || _a === void 0 ? void 0 : _a.placeholderEl.offsetHeight) !== null && _b !== void 0 ? _b : 0;\n    let maxItemIndex = getItemsInContainerEndIndex(containerEl) - 1;\n    let affectedStart = Math.min(maxItemIndex, Math.min(newEventualIndex, previousEventualIndex));\n    let affectedEnd = Math.min(maxItemIndex, Math.max(newEventualIndex, previousEventualIndex));\n    if (maxItemIndex === -1) {\n        return; // Empty container, nothing to animate.\n    }\n    // Note: we are using actual oldIndex below, not previousIndex.\n    // This is because we have to deal with activeEl affecting offsets,\n    // even though it's not visible.\n    // Previous index doesn't matter any more here, it was only\n    // for determining the affected range.\n    for (let i = affectedStart; i <= affectedEnd; ++i) {\n        let otherEl = containerEl.children[i];\n        if (dragState.dragKind === DragKind.Move && otherEl === dragState.pickedEl)\n            continue;\n        let afterOld = (dragState.dragKind === DragKind.Move &&\n            containerEl === dragState.from.containerEl &&\n            i >= dragState.from.index);\n        let afterNew = afterOld ? i > newEventualIndex : i >= newEventualIndex;\n        if (afterNew && afterOld) {\n            Anim.start(containerEl, [otherEl], activeToPlaceholderOffset, animMs);\n        }\n        else if (afterNew) {\n            Anim.start(containerEl, [otherEl], nothingToPlaceholderOffset, animMs);\n        }\n        else if (afterOld) {\n            Anim.start(containerEl, [otherEl], activeToNothingOffset, animMs);\n        }\n        else {\n            Anim.start(containerEl, [otherEl], 0, animMs);\n        }\n    }\n}\n","export const animMs = 100;\n// Id returned by requestAnimationFrame. Always reset to 0 when no frame is\n// requested.\nlet animFrameRequestId = 0; // 0 is never used as actual id.\n// Currently running requestAnimationFrame-based animations.\n// FUTURE COMPAT:\n// At the moment, only y-translation of CSS-transform can be animated,\n// but it may be extended to other properties or replaced with CSS-transition\n// based animations.\n// The Anim class is written to support animating several elements in parallel,\n// however it is not used that way and most likely it will eventually be\n// converted to only handle a single element, but this is not guaranted.\nlet anims = [];\n// Anim elements from Anim, but keyed by the animated elements.\n// Theoretically can contain more entries than anims, if we have Anim handling\n// several elements in parallel, but this feature is not currently used.\nlet animsByElem = new Map();\n// Most recent x and y values (in pixel) set in translate(x, y) part\n// of the CSS transform set on an element animated with Anim. If the transform\n//  is unset or set to translate(0, 0), no entry is stored.\n// TODO: Invent some better interface to tap into this information than just\n// exporting it.\nexport let transformsByElem = new Map();\nfunction animationFrame(timestamp) {\n    animFrameRequestId = 0; // Allow scheduling for the next frame.\n    let needsNextFrame = false;\n    // Iterate backwards to allow simple removal.\n    for (let i = anims.length - 1; i >= 0; --i) {\n        if (anims[i].animationFrame(timestamp)) {\n            needsNextFrame = true;\n        }\n        else {\n            anims[i].remove();\n        }\n    }\n    if (needsNextFrame) {\n        animFrameRequestId = requestAnimationFrame(animationFrame);\n    }\n}\n// Anim is implemented to hold an array of elems, but we actually rely on it\n// holding only one (which means we can delete the whole old anim when adding\n// new one for the same element).\nexport class Anim {\n    constructor(parentEl, elems, startYTranslation, targetYTranslation, durationMs) {\n        // assert(elems.length);\n        this.parentEl = parentEl;\n        this.elems = elems;\n        this.startYTranslation = startYTranslation;\n        this.targetYTranslation = targetYTranslation;\n        this.durationMs = durationMs;\n        this.startTime = null; // Will be filled in in the animation frame.\n        this.endTime = null;\n    }\n    static start(parentEl, elems, targetYTranslation, durationMs, startYTranslation = null) {\n        // How the actual, visible position differs from offsetTop.\n        if (startYTranslation === null) {\n            // TODO: Group the elements with the same initial translation.\n            // Round the initial translation to avoid sub-pixel differences.\n            // Alternatively work it around so that we _know_ all elements\n            // have the same starting transform - generating all these rects\n            // is a lot of useless computation and allocation.\n            for (let elem of elems) {\n                startYTranslation = (transformsByElem.get(elem) || [0, 0])[1];\n                if (startYTranslation !== targetYTranslation) {\n                    Anim.add(elem, new Anim(parentEl, [elem], startYTranslation, targetYTranslation, durationMs));\n                }\n                else {\n                    let currentAnim = animsByElem.get(elem);\n                    if (currentAnim) {\n                        currentAnim.remove();\n                    }\n                }\n            }\n        }\n        else {\n            // Immediately make sure that the elements are where they are supposed to start.\n            let transformString = `translateY(${startYTranslation}px)`;\n            for (let elem of elems) {\n                elem.style.transform = transformString;\n                Anim.add(elem, new Anim(parentEl, [elem], startYTranslation, targetYTranslation, durationMs));\n            }\n        }\n        if (!animFrameRequestId) {\n            animFrameRequestId = requestAnimationFrame(animationFrame);\n        }\n    }\n    static add(elem, anim) {\n        // Replace any old anim for this elem.\n        let previousAnim = animsByElem.get(elem);\n        if (previousAnim) {\n            anims[anims.indexOf(previousAnim)] = anim;\n        }\n        else {\n            anims.push(anim);\n        }\n        animsByElem.set(elem, anim);\n    }\n    // Will return true if the next frame should be requested.\n    animationFrame(timestamp) {\n        if (!this.startTime) {\n            this.startTime = timestamp;\n            this.endTime = timestamp + this.durationMs;\n            return true; // Do nothing\n        }\n        // Note: startTime is defined, so endTime is, too.\n        let advancementRate = timestamp >= this.endTime ? 1 : (timestamp - this.startTime) / this.durationMs;\n        let currentYTranslation = advancementRate * this.targetYTranslation + (1 - advancementRate) * this.startYTranslation;\n        let transformString = `translateY(${currentYTranslation}px)`;\n        for (let elem of this.elems) {\n            if (currentYTranslation === 0) {\n                transformsByElem.delete(elem);\n            }\n            else {\n                transformsByElem.set(elem, [0, currentYTranslation]);\n            }\n            elem.style.transform = transformString;\n        }\n        return (advancementRate < 1);\n    }\n    remove() {\n        for (let elem of this.elems) {\n            animsByElem.delete(elem);\n        }\n        anims[anims.indexOf(this)] = anims[anims.length - 1];\n        anims.pop();\n    }\n}\n","function preventSingleHandler(event) {\n    // We can't really prevent the browser for generating a click, but we\n    // can capture it and stop all effects.\n    event.stopPropagation();\n    event.preventDefault();\n    document.removeEventListener('click', preventSingleHandler, true);\n}\nexport function preventNextClick() {\n    document.addEventListener('click', preventSingleHandler, true);\n}\nexport function preventImmediateClick() {\n    document.addEventListener('click', preventSingleHandler, true);\n    // We want to only prevent click event that is already generated,\n    // so we will remove the handler right after the current queue is\n    // processed.\n    setTimeout(removeClickBlocker, 0);\n}\nexport function removeClickBlocker() {\n    document.removeEventListener('click', preventSingleHandler, true);\n}\n","import { expando } from \"./expando\";\nimport { dragState, StateEnum } from \"./state\";\n// Get elem's depth in the DOM tree.\n// Note: no special handling for elements not attached to actual document.\nexport function getDomDepth(elem) {\n    let result = 0;\n    for (elem = elem && elem.parentElement; elem; elem = elem.parentElement) {\n        ++result;\n    }\n    return result;\n}\n// Get the first index for items that we consider for drag and drop\n// end positioning. Skip anything with display: none.\nexport function getItemsInContainerStartIndex(containerEl) {\n    for (let i = 0; i < containerEl.children.length; ++i) {\n        if (getComputedStyle(containerEl.children[i]).display !== 'none') {\n            return i;\n        }\n    }\n    // Nothing was found. That means that getItemsInContainerEnd() will also\n    // find nothing and return 0, so let's return 0 for start/end consistency.\n    return 0;\n}\n// Get the after-last index for items that we consider for drag and drop\n// end positioning.\n// Skip the temporary Omicron's elements at the end of the container,\n// as well as anything with display: none.\nexport function getItemsInContainerEndIndex(containerEl) {\n    var _a;\n    const floatEl = dragState === null || dragState === void 0 ? void 0 : dragState.floatEl;\n    const placeholderEl = (dragState === null || dragState === void 0 ? void 0 : dragState.state) === StateEnum.PendingDrag ? (_a = dragState.to) === null || _a === void 0 ? void 0 : _a.placeholderEl : undefined;\n    for (let i = containerEl.children.length - 1; i >= 0; --i) {\n        const candidate = containerEl.children[i];\n        if (candidate !== floatEl &&\n            candidate !== placeholderEl &&\n            getComputedStyle(candidate).display !== 'none') {\n            // i is the index of last actual element, so the end index is i+1.\n            return i + 1;\n        }\n    }\n    return 0;\n}\nexport function getItemFromContainerEvent(event, options) {\n    var _a;\n    let containerEl = event.currentTarget;\n    let result = null;\n    let handleFound = false;\n    for (let el = event.target; el !== containerEl; el = el.parentElement) {\n        if (options.filterSelector && el.matches(options.filterSelector)) {\n            return null;\n        }\n        if (options.handleSelector && el.matches(options.handleSelector)) {\n            handleFound = true;\n        }\n        result = el;\n    }\n    // Returns null if the event is directly on the container,\n    // or the element was filtered out for any reason.\n    if (result &&\n        ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag || result !== ((_a = dragState.to) === null || _a === void 0 ? void 0 : _a.placeholderEl)) &&\n        (!options.draggableSelector || result.matches(options.draggableSelector)) &&\n        (handleFound || !options.handleSelector))\n        return result;\n    else {\n        return null;\n    }\n}\nexport function hasContainerAncestor(element) {\n    for (let el = element.parentElement; el; el = el.parentElement) {\n        if (expando in el) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { dragState, StateEnum } from \"./state\";\nexport function cancelIfOmicronActive(event) {\n    if (!dragState || (dragState.touchDrag && dragState.state === StateEnum.PreDrag)) {\n        return;\n    }\n    if (event.cancelable) {\n        event.preventDefault();\n    }\n}\nexport function cancelIfCancellable(event) {\n    if (event.cancelable) {\n        event.preventDefault();\n    }\n}\nconst eventListenerOptionsArg = { passive: false, capture: false };\nexport function toggleListeners(toggleOn, element, eventHandlerPairs) {\n    const toggle = toggleOn ? HTMLElement.prototype.addEventListener : HTMLElement.prototype.removeEventListener;\n    for (const [eventName, handler] of eventHandlerPairs) {\n        toggle.call(element, eventName, handler, eventListenerOptionsArg);\n    }\n}\n","export const expando = '__omicronDragAndDropData__';\n","// These are types that user interacts with directly.\nexport var DragKind;\n(function (DragKind) {\n    DragKind[DragKind[\"Move\"] = 0] = \"Move\";\n    DragKind[DragKind[\"Copy\"] = 1] = \"Copy\";\n})(DragKind || (DragKind = {}));\n","import { expando } from './expando';\nexport class ForbiddenIndices {\n    constructor() {\n        this.forbiddenInsertionIndicesCache = new Map();\n    }\n    isForbiddenIndex(containerEl, pickedEl, insertionIndex) {\n        return this.getForbiddenInsertionIndices(containerEl, pickedEl).has(insertionIndex);\n    }\n    getForbiddenInsertionIndices(containerEl, pickedEl) {\n        let cachedValue = this.forbiddenInsertionIndicesCache.get(containerEl);\n        if (cachedValue) {\n            return cachedValue;\n        }\n        const fn = containerEl[expando].options.forbiddenInsertionIndicesFn;\n        let newValue;\n        if (typeof fn === 'function') {\n            newValue = new Set(fn(containerEl, pickedEl));\n        }\n        else {\n            newValue = new Set();\n        }\n        this.forbiddenInsertionIndicesCache.set(containerEl, newValue);\n        return newValue;\n    }\n}\n","import { getDomDepth } from \"./dom-traversal\";\n// List of containerData for all the initialized container elements\n// currently under the pointer, at all times (i.e. not only when the drag\n// is active).\n// Updated with pointerenter/pointerleave events.\n// Sorted from the deepest to most shallow in the DOM tree.\nexport const hoverContainersByDepth = [];\nexport function getHoverContainersDeeperThan(domDepth) {\n    return hoverContainersByDepth.filter((container) => container.domDepth > domDepth);\n}\nexport function containerHoverEntered(containerData) {\n    containerData.domDepth = getDomDepth(containerData.el);\n    if (hoverContainersByDepth.indexOf(containerData) === -1) {\n        hoverContainersByDepth.push(containerData);\n        hoverContainersByDepth.sort(cmpDomDepth);\n    }\n}\nexport function containerHoverLeft(containerData) {\n    let delIdx;\n    if ((delIdx = hoverContainersByDepth.indexOf(containerData)) !== -1) {\n        hoverContainersByDepth.splice(delIdx, 1);\n    }\n}\n// Compare function for hoverContainersByDepth.\nfunction cmpDomDepth(a, b) {\n    return b.domDepth - a.domDepth;\n}\n","import { DragKind } from './external-types';\nimport { dragState } from './state';\n// Insertion index is the index at which we will insert the item.\n// Eventual index is the index at which the inserted item will end up.\n// It works like this:\n//   containerEl.insertBefore(insertedItem, containerEl.children[insertionIndex])\n//   const eventualIndex = Array.from(containerEl.children).indexOf(insertedItem))\n//\n// This means that eventualIndex is usually the same as insertionIndex,\n// but there is a discrepancy when we are:\n//   a) moving the item (as opposed to copying it),\n//   b) inside a single container (as opposed to moving/copying to another container),\n//   c) and the insertionIndex is greater than the index before move\n//           (i.e. moving element further/down inside the container),\n// in which case eventualIndex is insertionIndex - 1.\nexport function insertionIndexFromEventualIndex(containerEl, eventualIndex) {\n    if (dragState && containerEl === dragState.from.containerEl && dragState.dragKind === DragKind.Move && eventualIndex > dragState.from.index) {\n        return eventualIndex + 1;\n    }\n    // Note: in case where nothing changes (we \"move\" item into the place it\n    // already is at) there are 2 possible values for insertionIndex - both\n    // dragState.from.index and dragState.from.index + 1 have that result.\n    // We return dragState.from.index in that case, but that is arbitrary.\n    return eventualIndex;\n}\nexport function eventualIndexFromInsertionIndex(containerEl, insertionIndex) {\n    if (dragState && containerEl === dragState.from.containerEl && dragState.dragKind === DragKind.Move && insertionIndex > dragState.from.index) {\n        return insertionIndex - 1;\n    }\n    return insertionIndex;\n}\n","export function makeInvisible(elem) {\n    // Theoretically some descendants can have visibility set explicitly\n    // to visible and then whey would be visible anyway, so let's double\n    // down with opacity: 0;\n    elem.style.visibility = 'hidden';\n    elem.style.opacity = '0';\n    elem.style.pointerEvents = 'none';\n    elem.classList.add('drag-active-item');\n}\nexport function cancelInvisible(elem) {\n    // Note: if there were any inline styles on the element, uh, we have\n    // just erased them. I think that is resonable to force users to just\n    // deal with it.\n    elem.classList.remove('drag-active-item');\n    elem.style.visibility = '';\n    elem.style.opacity = '';\n    elem.style.pointerEvents = '';\n}\n","import { DragKind, } from './external-types';\n// Options for an Omicron container.\n// Actual options for a container are stored in\n// containerEl[expando].options.\nexport class ContainerOptions {\n    constructor() {\n        // CSS selector for draggable children of the container. The selector\n        // is evaluated on pointerdown on the pressed item.\n        // When left undefined, all elements in the container are draggable.\n        // When the matcher fails, the pointerdown event is allowed to bubble,\n        // otherwise the stopPropagation is called.\n        // FUTURE COMPAT: At the moment, when the matcher fails, the pointerdown\n        // event is allowed to bubble further (allowing e.g. an ancestor of the\n        // container to be dragged). An option to control this behavior can be\n        // added in the future.\n        this.draggableSelector = null;\n        // CSS selector for elements that can't be used to drag an item.\n        // If any DOM element on the path from event.target (of pointerdown event)\n        // to the candidate item matches this selector, the drag is not considered.\n        // When the filter matcher hits any element on the path, the pointerdown\n        // event is allowed to bubble, otherwise the stopPropagation is called.\n        // FUTURE COMPAT: Options to control the bubbling behavior may be added,\n        // similar as for draggableSelector.\n        this.filterSelector = null;\n        // CSS selector for handle element. If a handle selector is defined,\n        // an item can be dragged only when grabbed by a handle-matching child\n        // (or must be a handle itself).\n        // If handleSelector is defined, and no element on the path from\n        // event.target to the item match handleSelector, the behavior is the same\n        // as if draggableSelector didn't match (draggableSelector itself must\n        // match anyway).\n        // FUTURE COMPAT: Options to control the bubbling behavior may be added,\n        // similar as for draggableSelector.\n        this.handleSelector = null;\n        this.allowPull = DragKind.Move;\n        this.allowDrop = true;\n        // Minimal (euclidean, px) distance the pointer needs to move from the initial\n        // position to trigger the drag before delay ends. Not applied for touch drag.\n        this.minimalMoveMouse = 5;\n        // Exact length of the preDrag phase for touch, and maximal for other pointers.\n        // For touch, this is a minimal time between pointerdown and the first touchmove\n        // to start the drag. If a touchmove/touchend/touchcancel happens earlier,\n        // the drag is cancelled, otherwise the drag starts `delay` ms after the initial\n        // pointerdown event.\n        // For mouse/pen, the drag starts _at the latest_ `delay` ms after the initial\n        // pointerdown, unless the pointer is released (pointerup). The drag can start\n        // earlier, if the pointer moves minimalMoveMouse px or more from initial point.\n        this.delay = 220;\n        // Enter guards define the area of the container that may be used to drag\n        // elements into it. After the container was entered (became toEl) the whole\n        // area can be used to drag the item inside the container.\n        // The guards define two margins, from the left end right edges of\n        // the container that are excluded from this drag-accepting area.\n        // This is useful when creating nested containers, to make it easier\n        // to reorder \"big\" elements in the \"big\" parent container, without\n        // accidentally entering the \"small\" child container.\n        // Guards without suffix are a rate of width, those with 'px' are in pixels.\n        this.enterGuardLeft = 0;\n        this.enterGuardLeftPx = 0;\n        this.enterGuardRight = 0;\n        this.enterGuardRightPx = 0;\n        // forbiddenInsertionIndicesFn can be used to make some indices invalid\n        // as newIndex.\n        // When entering new container (as toEl), forbiddenInsertionIndicesFn\n        // defined _for that entered container_ is evaluated. The forbidden\n        // indices are skipped when considering moves inside the toEl.\n        // forbiddenInsertionIndicesFn will be called once per container during\n        // each drag, and the result will be cached.\n        this.forbiddenInsertionIndicesFn = null;\n        // createFloatElemFn: null,\n        // Scale factor of floatEl transform. Can be used to make the dragged\n        // element slightly smaller. The transform-origin for the scale is set\n        // where the pointer is located on the original element.\n        this.floatElScale = 1;\n        // Chrome on Android will highlight every element that you tap with mild\n        // blue color. That is irrelevant and distracting when using drag and drop,\n        // so we turn this off by default, but you can disable that feature.\n        this.setWebkitTapHighlightColorTransparent = true;\n        // Argument to pass to navigator.vibrate when the drag is activated.\n        // Set to 0 to disable.\n        // The value is the length of vibration in milliseconds (it may be also\n        // a pattern, but it really doesn't make sense with drag and drop).\n        this.dragStartVibration = 25;\n        // onBeforePreDrag: Called just before preDrag starts.\n        // Return explicit `false` to cancel the drag.\n        // Return DragKind to override the allowPull behavior for this particular\n        // drag.\n        this.onBeforePreDrag = null;\n        // The element was chosen and the wait starts for the delay or minimal mouse\n        // move to start dragging. The return value is ignored.\n        // onPreDragStart(containerEl, activeEl, event)\n        this.onPreDragStart = null;\n        // Called just after the conditions for the drag start are met, but before\n        // any styling (transforms) for the drag started, before placeholder\n        // and floatEl are created. The return value is ignored.\n        this.onBeforeDragStart = null;\n        // The floatEl to be placed under the pointer was created. You can edit its\n        // internal DOM structure.\n        // Use it to remove or override any \"pointer-events: all\" rules you might\n        // have created inside the element, as they will break the drag logic.\n        this.onFloatElementCreated = null;\n        // The element is actually being dragged now. The return value is ignored.\n        this.onDragStart = null;\n        // The container became toEl. This will fire right after onDragStart\n        // for the fromEl (being also toEl) and then for every entered container.\n        this.onContainerEntered = null;\n        // The container is no longer toEl. This will fire at the end of\n        // the drag, too, before the drag finish events.\n        this.onContainerLeft = null;\n        // The same event format is shared between onInternalChange,\n        // onDropToOtherContainer, onDropFromOtherContainer.\n        // Called on change where toEl === fromEl.\n        this.onInternalChange = null;\n        // Called on fromEl when toEl !== fromEl.\n        this.onDropToOtherContainer = null;\n        // Called on toEl when toEl !== fromEl.\n        this.onDropFromOtherContainer = null;\n        // The drag or pre-drag was finished. In case it was a sucessful drag,\n        // called after relevant onInternalChange/onDrop callback, with the same\n        // event.\n        // onDragFinished(dragEndEvent)\n        this.onDragFinished = null;\n    }\n}\n;\n","let saved;\nexport function disableOverscrollBehavior() {\n    if (saved)\n        return;\n    // Prevent the scroll-to-refresh behavior and the effect\n    // of bumping into the scroll end on mobile.\n    saved = {\n        htmlOvescrollBehavior: document.documentElement.style.overscrollBehavior,\n        bodyOvescrollBehavior: document.body.style.overscrollBehavior,\n    };\n    document.documentElement.style.overscrollBehavior = 'none';\n    document.body.style.overscrollBehavior = 'none';\n}\nexport function revertOverscrollBehavior() {\n    if (!saved)\n        return;\n    document.documentElement.style.overscrollBehavior = saved.htmlOvescrollBehavior;\n    document.body.style.overscrollBehavior = saved.bodyOvescrollBehavior;\n    saved = null;\n}\n","import { dragState } from './state';\n// Id returned by requestAnimationFrame. Always reset to 0 when no frame is\n// requested.\nlet animFrameRequestId = 0; // 0 is never used as actual id.\nlet scrollers = [];\nlet activeScrollers = [];\n// Last timestamp (as passed to requestAnimationFrame callback) when\n// active scrollers animation/scroll positions were updated.\n// This is the base for calculating the scroll distance for the current frame.\n// Always null if activeScrollers array is empty.\nlet lastScrollAnimationTimestamp = null;\nfunction collectScrollers(elem) {\n    let result = [];\n    // TODO: Include document.scrollingElement\n    for (; elem; elem = elem.parentElement) {\n        let style = getComputedStyle(elem);\n        let horizontalScroll = style.overflowX === 'auto' || style.overflowX === 'scroll';\n        let verticalScroll = style.overflowY === 'auto' || style.overflowY === 'scroll';\n        if (!horizontalScroll && !verticalScroll) {\n            continue;\n        }\n        let domRect = elem.getClientRects()[0];\n        // Create our own structure. Origina DOMRect is read-only, and\n        // we want to be able to make updates.\n        let rect = {\n            left: domRect.left,\n            top: domRect.top,\n            right: domRect.right,\n            bottom: domRect.bottom,\n        };\n        result.push({\n            el: elem,\n            rect,\n            horizontal: horizontalScroll,\n            vertical: verticalScroll,\n            snap: Boolean(elem.dataset.omicronScrollSnap),\n            snapCooldown: false,\n        });\n    }\n    return result;\n}\n// This is a helper for updateActiveScrollers, only to be called from there.\nfunction activateScroller(scroller, horizontal, vertical, speedInput) {\n    if (scroller.snap) {\n        if (!scroller.snapCooldown) {\n            if (horizontal) {\n                scroller.el.scrollLeft += horizontal * scroller.el.clientWidth;\n            }\n            if (vertical) {\n                scroller.el.scrollTop += vertical * scroller.el.clientHeight;\n            }\n            scroller.snapCooldown = true; // Prevent immediate re-activation.\n        }\n        // TODO: Either force recomputing the rects for other scrollers after\n        // the scroll, or maybe just give up caching the rects.\n    }\n    else {\n        activeScrollers.push({\n            scrollerIndex: scrollers.indexOf(scroller),\n            scrollerEl: scroller.el,\n            horizontal,\n            vertical,\n            speedInput,\n        });\n    }\n}\nconst minScrollSpeed = 0.3; // In pixels per millisecond.\nconst maxScrollSpeed = 0.7; // In pixels per millisecond.\nconst maxScrollSpeedIncrease = maxScrollSpeed - minScrollSpeed;\nfunction animationFrame(timestamp) {\n    animFrameRequestId = 0; // Allow scheduling for the next frame.\n    if (activeScrollers.length === 0) {\n        return;\n    }\n    if (lastScrollAnimationTimestamp) {\n        let frameTime = timestamp - lastScrollAnimationTimestamp;\n        // Animate. If lastScrollAnimationTimestamp is not set, the animation\n        // will start on the next frame.\n        for (let s of activeScrollers) {\n            // Notice the difference between entries in activeScrollers and\n            // scrollers arrays, they are different.\n            const scrollSpeed = minScrollSpeed + s.speedInput * maxScrollSpeedIncrease;\n            if (s.vertical) {\n                const oldValue = s.scrollerEl.scrollTop;\n                const diff = s.vertical * scrollSpeed * frameTime;\n                s.scrollerEl.scrollTop += diff;\n                const actualDiff = s.scrollerEl.scrollTop - oldValue;\n                if (actualDiff !== 0) {\n                    updateScrollerRects(s.scrollerIndex, actualDiff, 0);\n                }\n            }\n            if (s.horizontal) {\n                const oldValue = s.scrollerEl.scrollLeft;\n                const diff = s.horizontal * scrollSpeed * frameTime;\n                s.scrollerEl.scrollLeft += diff;\n                const actualDiff = s.scrollerEl.scrollLeft - oldValue;\n                if (actualDiff !== 0) {\n                    updateScrollerRects(s.scrollerIndex, 0, actualDiff);\n                }\n            }\n        }\n    }\n    lastScrollAnimationTimestamp = timestamp;\n    animFrameRequestId = requestAnimationFrame(animationFrame);\n}\nfunction updateScrollerRects(updateBefore, vDiff, hDiff) {\n    for (let i = 0; i < updateBefore; ++i) {\n        const rect = scrollers[i].rect;\n        rect.top -= vDiff;\n        rect.bottom -= vDiff;\n        rect.left -= hDiff;\n        rect.right -= hDiff;\n    }\n}\n// Call this when active container changes.\nexport function updateScrollers(elem) {\n    scrollers = collectScrollers(elem);\n}\nconst scrollActivationMargin = 60; // In pixels. TODO: Allow adjusting with element markup.\n// Call this when mouse moves.\nexport function updateActiveScrollers() {\n    // TODO: Remove array allocation?\n    activeScrollers = [];\n    if (!dragState) {\n        lastScrollAnimationTimestamp = null;\n        return;\n    }\n    const xLast = dragState.currentPointerPos.x;\n    const yLast = dragState.currentPointerPos.y;\n    for (let scroller of scrollers) {\n        if (scroller.horizontal) {\n            if (xLast < scroller.rect.left + scrollActivationMargin) {\n                // Scrolling left.\n                activateScroller(scroller, -1, 0, (scroller.rect.left + scrollActivationMargin - xLast) / scrollActivationMargin);\n            }\n            else if (xLast > scroller.rect.right - scrollActivationMargin) {\n                // Scrolling right.\n                activateScroller(scroller, 1, 0, (xLast - scroller.rect.right + scrollActivationMargin) / scrollActivationMargin);\n            }\n            else {\n                scroller.snapCooldown = false;\n            }\n        }\n        if (scroller.vertical) {\n            if (yLast < scroller.rect.top + scrollActivationMargin) {\n                // Scrolling up.\n                activateScroller(scroller, 0, -1, (scroller.rect.top + scrollActivationMargin - yLast) / scrollActivationMargin);\n            }\n            else if (yLast > scroller.rect.bottom - scrollActivationMargin) {\n                // Scrolling down.\n                activateScroller(scroller, 0, 1, (yLast - scroller.rect.bottom + scrollActivationMargin) / scrollActivationMargin);\n            }\n        }\n    }\n    if (activeScrollers.length === 0) {\n        // Not animating (any more). Let the next animation know that it needs\n        // to count itself in, in case we didn't request previous frames.\n        lastScrollAnimationTimestamp = null;\n    }\n    else {\n        // Request animation for the active scrollers.\n        if (!animFrameRequestId) {\n            animFrameRequestId = requestAnimationFrame(animationFrame);\n        }\n    }\n}\n","let saved;\nexport function disableUserSelectOnBody() {\n    if (saved)\n        return;\n    saved = {\n        bodyUserSelect: document.body.style.userSelect,\n        bodyWebkitUserSelect: document.body.style.webkitUserSelect,\n        bodyWebkitTouchCallout: document.body.style.webkitTouchCallout,\n    };\n    document.body.style.userSelect = 'none';\n    document.body.style.webkitUserSelect = 'none';\n    document.body.style.webkitTouchCallout = 'none';\n}\nexport function revertUserSelectOnBody() {\n    if (!saved)\n        return;\n    document.body.style.userSelect = saved.bodyUserSelect;\n    document.body.style.webkitUserSelect = saved.bodyWebkitUserSelect;\n    document.body.style.webkitTouchCallout = saved.bodyWebkitTouchCallout;\n    saved = null;\n}\n","export var StateEnum;\n(function (StateEnum) {\n    StateEnum[StateEnum[\"PreDrag\"] = 0] = \"PreDrag\";\n    StateEnum[StateEnum[\"PendingDrag\"] = 1] = \"PendingDrag\";\n    StateEnum[StateEnum[\"AfterDrag\"] = 2] = \"AfterDrag\";\n})(StateEnum || (StateEnum = {}));\n// Perhaps it would be better to write these assertions inline, and let\n// Typescript figure out that they are, indeed, correct.\nexport function isPreDrag(state) {\n    return !!state && state.state === StateEnum.PreDrag;\n}\nexport function isPendingDrag(state) {\n    return !!state && state.state === StateEnum.PendingDrag;\n}\nexport function isAfterDrag(state) {\n    return !!state && state.state === StateEnum.AfterDrag;\n}\nexport class BadStateError extends Error {\n    constructor(expectedState) {\n        super(`Drag state assertion failed: expected state ${StateEnum[expectedState]}, but actual is ${dragState ? StateEnum[dragState.state] : '<no drag>'}`);\n    }\n}\nexport let dragState = null;\nexport function setDragState(newDragState) {\n    // TODO: Some logic might happen here, like changing the listeners, perhaps.\n    dragState = newDragState;\n}\n","import { dragState, StateEnum } from './state';\n// Id returned by requestAnimationFrame. Always reset to 0 when no frame is\n// requested.\nlet animFrameRequestId = 0; // 0 is never used as actual id.\nfunction animationFrame(timestamp) {\n    animFrameRequestId = 0; // Allow scheduling for the next frame.\n    if (dragState && dragState.state === StateEnum.PendingDrag) {\n        // TODO: adjust for scroll or other changes of the base.\n        dragState.floatEl.style.transform = `translate(${dragState.floatElPos.x}px,${dragState.floatElPos.y}px) scale(${dragState.floatElScale})`;\n    }\n}\nexport function updateFloatElOnNextFrame() {\n    if (!animFrameRequestId) {\n        animFrameRequestId = requestAnimationFrame(animationFrame);\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { animateMoveInsideContainer } from \"./animate-move\";\nimport { Anim, animMs, transformsByElem } from \"./anims\";\nimport { preventImmediateClick } from \"./click-blocker\";\nimport { getItemFromContainerEvent, getItemsInContainerEndIndex, getItemsInContainerStartIndex, hasContainerAncestor } from \"./dom-traversal\";\nimport { cancelIfCancellable, cancelIfOmicronActive, toggleListeners } from \"./event-utils\";\nimport { expando } from \"./expando\";\nimport { DragKind } from \"./external-types\";\nimport { ForbiddenIndices } from \"./forbidden-indices\";\nimport { containerHoverEntered, containerHoverLeft, getHoverContainersDeeperThan } from \"./hover-tracker\";\nimport { insertionIndexFromEventualIndex } from \"./index-conversions\";\nimport { cancelInvisible, makeInvisible } from \"./invisible-item\";\nimport { ContainerOptions } from \"./options\";\nimport { disableOverscrollBehavior, revertOverscrollBehavior } from \"./overscroll-behavior\";\nimport { updateActiveScrollers, updateScrollers } from \"./scrollers\";\nimport { disableUserSelectOnBody, revertUserSelectOnBody } from \"./selection-control\";\nimport { BadStateError, dragState, setDragState, StateEnum } from \"./state\";\nimport { updateFloatElOnNextFrame } from \"./update-float-el-on-next-frame\";\nfunction initDragContainer(container, options) {\n    if (container[expando]) {\n        return; // Ignore repeated calls.\n    }\n    const containerEl = Object.assign(container, {\n        [expando]: {\n            el: container,\n            options: Object.assign(new ContainerOptions(), options || {}),\n            domDepth: 0, // To be updated dynamically when added to hoverContainers.\n        },\n    });\n    toggleListeners(true, document, [\n        ['dragover', cancelIfOmicronActive],\n        ['touchmove', cancelIfOmicronActive],\n    ]);\n    toggleListeners(true, containerEl, [\n        ['pointerdown', anyState_container_PointerDown],\n        ['pointerenter', anyState_container_PointerEnter],\n        ['pointerleave', anyState_container_PointerLeave],\n    ]);\n    if (containerEl[expando].options.setWebkitTapHighlightColorTransparent &&\n        ('webkitTapHighlightColor' in containerEl.style)) {\n        containerEl.style.webkitTapHighlightColor = 'transparent';\n    }\n    if (getComputedStyle(containerEl).position === 'static') {\n        // The container needs to be positioned to work correctly\n        // with absolutely positioned placeholder.\n        containerEl.style.position = 'relative';\n    }\n}\nfunction toggleEvents_statePreDrag(toggleOn, touchDrag) {\n    if (touchDrag) {\n        toggleListeners(toggleOn, document, [\n            ['touchstart', statePreDrag_window_TouchStart],\n            ['touchmove', statePreDrag_window_TouchMove],\n            ['touchend', statePreDrag_window_TouchEndOrCancel],\n            ['touchcancel', statePreDrag_window_TouchEndOrCancel],\n            ['pointermove', cancelIfCancellable],\n        ]);\n    }\n    else {\n        toggleListeners(toggleOn, document, [\n            ['pointermove', statePreDrag_window_PointerMove],\n            ['pointerup', statePreDrag_window_PointerUpOrCancel],\n            ['pointercancel', statePreDrag_window_PointerUpOrCancel],\n        ]);\n    }\n}\nfunction toggleEvents_stateDrag(toggleOn, touchDrag) {\n    if (touchDrag) {\n        toggleListeners(toggleOn, document, [\n            // For preventing multi-touch while dragging.\n            ['touchstart', stateDrag_window_TouchStart],\n            // We need to capture touchmove events in order to call\n            // .preventDefault() on them and stop the scrolling.\n            // Calling .preventDefault() on PointerEvents doesn't do that.\n            ['touchmove', stateDrag_window_TouchMove],\n            ['touchend', stateDrag_window_TouchEnd],\n            ['touchcancel', stateDrag_window_TouchCancel],\n            ['pointermove', cancelIfCancellable],\n        ]);\n    }\n    else {\n        toggleListeners(toggleOn, document, [\n            ['pointermove', stateDrag_window_PointerMove],\n            ['pointerup', stateDrag_window_PointerUp],\n            ['pointercancel', stateDrag_window_PointerCancel],\n        ]);\n    }\n    toggleListeners(toggleOn, document, [\n        ['selectstart', cancelIfCancellable],\n    ]);\n}\nfunction anyState_container_PointerDown(event) {\n    // Unconditionally release pointer capture. I do that before any checks\n    // for pending drag to avoid unnecessary races with touchstart.\n    const containerEl = event.currentTarget;\n    if (!hasContainerAncestor(containerEl)) {\n        // Only let the event propagate if there are other containers below,\n        // but don't let it go outside.\n        event.stopPropagation();\n    }\n    if (dragState) {\n        return;\n    }\n    if (event.pointerType === 'mouse' && event.buttons !== 1) {\n        // When using mouse, allow only the main button.\n        // event.button on PointerEvent unfortunately doesn't work,\n        // but event.buttons does.\n        // TODO: We should probably check the button number for\n        // pointerType === 'pointer' as well, just not for touch.\n        return;\n    }\n    const touchDrag = (event.pointerType === 'touch');\n    const containerData = containerEl[expando];\n    const containerOptions = containerData.options;\n    if (containerOptions.allowPull === false) {\n        // Starting drag in this container is not allowed at all.\n        return;\n    }\n    let dragKind = containerOptions.allowPull;\n    const pickedEl = getItemFromContainerEvent(event, containerData.options);\n    if (!pickedEl) {\n        // TODO: Add an option to .stopPropagation() here as well, to prevent\n        // dragging the container by elements, event if not by the handle?\n        return;\n    }\n    // Allow the callback to cancel the preDrag before it starts.\n    // This can be used to implement some dynamic barrier on top of\n    // draggableSelector, filterSelector, and handleSelector.\n    if (typeof containerOptions.onBeforePreDrag === 'function') {\n        const ret = containerOptions.onBeforePreDrag(containerEl, pickedEl, event);\n        switch (ret) {\n            case false:\n                // Cancel drag.\n                return;\n            case DragKind.Move:\n            case DragKind.Copy:\n                // Override drag kind.\n                dragKind = ret;\n                break;\n            default:\n                break;\n        }\n    }\n    // Only stop propagation to ancestor containers after deciding that\n    // something was indeed grabbed.\n    // That allows the nested container to be dragged by contents when using\n    // handle/filter, or just being grabbed by the padding/empty area.\n    event.stopPropagation();\n    const from = {\n        containerEl,\n        index: Array.from(containerEl.children).indexOf(pickedEl),\n    };\n    toggleEvents_statePreDrag(true, touchDrag);\n    const initialPickupRect = pickedEl.getClientRects()[0];\n    const pickupPointerPos = {\n        x: event.clientX,\n        y: event.clientY,\n    };\n    // I add some arbitrary difference to give the effect of the element\n    // snapping out of place, instead of just staying in place silently.\n    const floatFromPointerOffset = {\n        x: initialPickupRect.x - pickupPointerPos.x + 16,\n        y: initialPickupRect.y - pickupPointerPos.y - 4,\n    };\n    // We are entering statePreDrag. We will start the drag after a delay, or if\n    // the mouse moves sufficiently far. We will cancel the drag if the touch\n    // moves too far before the delay.\n    // IMPORTANT: Some logic depends on startDrag being called asynchronously,\n    // so even if the delay is 0, setTimeout should still be used.\n    const delay = containerOptions.delay;\n    const preDragTimeoutId = setTimeout(startDrag, delay);\n    if (typeof containerOptions.onPreDragStart === 'function') {\n        containerOptions.onPreDragStart(containerEl, pickedEl, event);\n    }\n    disableUserSelectOnBody();\n    // Ensure the element has pointer capture. This happens automatically\n    // for touch, but not for mouse.\n    // Pointer capture is important to avoid calls to enterContainer\n    // and leaveContainer during preDrag - these would mess up the drag\n    // setup WRT toEl. The capture will be released afterwards, allowing\n    // immediate execution of leaveContainer/enterContainer if necessary.\n    const pointerDownTarget = event.target;\n    pointerDownTarget.setPointerCapture(event.pointerId);\n    setDragState({\n        state: StateEnum.PreDrag,\n        pointerId: event.pointerId,\n        pointerDownTarget,\n        touchDrag,\n        from,\n        dragKind,\n        pickedEl,\n        initialPickupRect,\n        pickupPointerPos,\n        floatFromPointerOffset,\n        currentPointerPos: pickupPointerPos,\n        floatElScale: containerOptions.floatElScale,\n        minimalMoveMouse: containerOptions.minimalMoveMouse,\n        forbiddenIndices: new ForbiddenIndices(),\n        preDragTimeoutId,\n    });\n}\nfunction startDrag() {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PreDrag)\n        throw new BadStateError(StateEnum.PreDrag);\n    // In case this was triggered by mouse, and not by the timeout itsef, we\n    // cancel the timeout.\n    clearTimeout(dragState.preDragTimeoutId);\n    let containerData = dragState.from.containerEl[expando];\n    const containerOptions = containerData.options;\n    if (typeof containerOptions.onBeforeDragStart === 'function') {\n        containerOptions.onBeforeDragStart(dragState.from.containerEl, dragState.pickedEl);\n    }\n    // Should we go over the whole activeEl subtree and mark the containers there\n    // as inactive? We may need to, actually.\n    toggleEvents_stateDrag(true, dragState.touchDrag);\n    toggleEvents_statePreDrag(false, dragState.touchDrag);\n    // Release default pointer capture. This is important that it happens only\n    // after dragStart, and that we keep the capture during preDrag - that saves\n    // us from some subtle race conditions. See issue #11 for context.\n    if (dragState.pointerDownTarget) {\n        // Pointermove events are by default all captured by the pointerdown's target.\n        // That means no pointerenter/pointerleave events, that we rely on, so\n        // we need to release the pointer capture.\n        // Source: https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter\n        dragState.pointerDownTarget.releasePointerCapture(dragState.pointerId);\n    }\n    disableOverscrollBehavior();\n    const floatEl = createFloatEl(dragState);\n    if (typeof containerOptions.onFloatElementCreated === 'function') {\n        containerOptions.onFloatElementCreated(floatEl, dragState.from.containerEl, dragState.pickedEl);\n    }\n    if (dragState.dragKind === DragKind.Move) {\n        makeInvisible(dragState.pickedEl);\n        // Schedule animation of moving pickedEl out of the container. In practice,\n        // We will almost always override it with another animation of \"insertion\",\n        // but sometimes it may happen that we actually leave the original container\n        // immediately.\n        animateMoveInsideContainer(dragState.from.containerEl, dragState.from.index, getItemsInContainerEndIndex(dragState.from.containerEl));\n    }\n    if (typeof containerOptions.onDragStart === 'function') {\n        containerOptions.onDragStart(dragState.from.containerEl, dragState.pickedEl);\n    }\n    if (typeof containerOptions.onContainerEntered === 'function') {\n        containerOptions.onContainerEntered(dragState.from.containerEl, dragState.pickedEl);\n    }\n    if (navigator.vibrate && containerData.options.dragStartVibration) {\n        // Unfortunately doesn't work if this drag is the first user interaction\n        // with the page. This is due to Chrome being a little bit too strict\n        // in requiring previous user interaction with the page before\n        // activating Vibration API.\n        // See https://stackoverflow.com/a/46189638/2468549.\n        navigator.vibrate(containerData.options.dragStartVibration);\n    }\n    setDragState(Object.assign(Object.assign({}, dragState), { state: StateEnum.PendingDrag, floatEl, floatElPos: {\n            x: dragState.currentPointerPos.x + dragState.floatFromPointerOffset.x,\n            y: dragState.currentPointerPos.y + dragState.floatFromPointerOffset.y,\n        } }));\n    // Synthethic update, to determine the insertion point.\n    // TODO: We might need to give it a hint that this is a drag start, after all.\n    updateOnMove({\n        clientX: dragState.currentPointerPos.x,\n        clientY: dragState.currentPointerPos.y,\n    });\n}\nfunction statePreDrag_window_TouchStart(event) {\n    if (dragState && event.touches.length !== 1) {\n        // We don't allow multi-touch during drag.\n        exitDrag(false);\n    }\n}\nfunction statePreDrag_window_TouchMove(event) {\n    // We may not be able to cancel the scroll any more after this event,\n    // so we have to give up the drag.\n    exitDrag(false);\n}\nfunction statePreDrag_window_TouchEndOrCancel(event) {\n    exitDrag(false);\n    // This is pre-drag and no move happened, so we allow the click,\n    // hence no preventDefault() call here.\n}\nfunction statePreDrag_window_PointerMove(event) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PreDrag)\n        throw new BadStateError(StateEnum.PreDrag);\n    if (event.pointerId !== dragState.pointerId) {\n        return;\n    }\n    const newX = dragState.currentPointerPos.x = event.clientX;\n    const newY = dragState.currentPointerPos.y = event.clientY;\n    let xDiff = newX - dragState.pickupPointerPos.x;\n    let yDiff = newY - dragState.pickupPointerPos.y;\n    let distanceSquaredFromInitial = xDiff * xDiff + yDiff * yDiff;\n    const minimalMoveMouse = dragState.minimalMoveMouse;\n    if (distanceSquaredFromInitial > minimalMoveMouse * minimalMoveMouse) {\n        startDrag();\n    }\n}\nfunction statePreDrag_window_PointerUpOrCancel(event) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PreDrag)\n        throw new BadStateError(StateEnum.PreDrag);\n    if (event.pointerId !== dragState.pointerId) {\n        return;\n    }\n    exitDrag(false);\n}\nfunction stateDrag_window_TouchStart(event) {\n    // We don't allow multi-touch during dragging.\n    exitDrag(false);\n}\nfunction stateDrag_window_TouchMove(event) {\n    if (event.cancelable) {\n        // Prevent scroll.\n        event.preventDefault();\n    }\n    const touch = event.touches.item(0);\n    if (!touch || event.touches.length !== 1) {\n        // We don't allow multi-touch during dragging.\n        exitDrag(false);\n        return;\n    }\n    handleMove(touch);\n}\nfunction stateDrag_window_PointerMove(event) {\n    if (event.pointerId !== (dragState === null || dragState === void 0 ? void 0 : dragState.pointerId)) {\n        return;\n    }\n    handleMove(event);\n}\n// The direction of the last pointer move in y-coordinates.\n// -1 when going up (lower y value), +1 when going down.\n// The last value is kept as long as the y-coord doesn't change.\nlet yDirection = -1;\n// This is to be called only when the pointer actually moves.\nfunction handleMove(evtPoint) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    // Update the mouse position.\n    if (evtPoint.clientY !== dragState.currentPointerPos.y) {\n        yDirection = evtPoint.clientY > dragState.currentPointerPos.y ? 1 : -1;\n    }\n    dragState.currentPointerPos.x = evtPoint.clientX;\n    dragState.currentPointerPos.y = evtPoint.clientY;\n    dragState.floatElPos.x =\n        dragState.currentPointerPos.x + dragState.floatFromPointerOffset.x;\n    dragState.floatElPos.y =\n        dragState.currentPointerPos.y + dragState.floatFromPointerOffset.y;\n    updateFloatElOnNextFrame();\n    updateOnMove(evtPoint);\n}\n// This is to be called both when pointer moves, and to invoke synthetic update\n// after scroll and on drag start.\nfunction updateOnMove(evtPoint) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    // If we are hovering over some containers that are descendants\n    // of toEl but we didn't enter them yet for any reason, let's reconsider.\n    const toElDomDepth = dragState.to ? dragState.to.containerEl[expando].domDepth : -1;\n    for (const hoverContainer of getHoverContainersDeeperThan(toElDomDepth)) {\n        if (maybeEnterContainer(hoverContainer, evtPoint)) {\n            // enterContainer took take care of handling the new position\n            // and animation, so our work here is done.\n            return;\n        }\n    }\n    const to = dragState.to;\n    if (!to) {\n        return;\n    }\n    updateActiveScrollers();\n    let updatedEventualIndex = findUpdatedEventualIndex(to.containerEl, evtPoint);\n    let updatedInsertionIndex = insertionIndexFromEventualIndex(to.containerEl, updatedEventualIndex);\n    if (updatedEventualIndex != to.insertionIndex && !dragState.forbiddenIndices.isForbiddenIndex(to.containerEl, dragState.pickedEl, updatedInsertionIndex)) {\n        let previousEventualIndex = to.eventualIndex;\n        to.eventualIndex = updatedEventualIndex;\n        to.insertionIndex = updatedInsertionIndex;\n        animateMoveInsideContainer(to.containerEl, previousEventualIndex, updatedEventualIndex);\n        updatePlaceholderAndNoMoveZone(to);\n    }\n}\n// By default, we optimize the search by going only from the current index\n// in the direction of mouseY, and only when the move is outside of\n// precomputed zone where we know no move happened. When insertionContainer\n// is supplied, we ignore both optimizations.\nfunction findUpdatedEventualIndex(containerEl, evtPoint) {\n    var _a, _b, _c, _d, _e, _f;\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    let ignoreCurrentNewIndex = containerEl !== ((_a = dragState.to) === null || _a === void 0 ? void 0 : _a.containerEl);\n    // TODO: There is some glitch in how mouseY works after autoscroll.\n    // I don't know what the issue is, but there is some shift introduced,\n    // perhaps at this place.\n    let mouseY = evtPoint.clientY - containerEl.getClientRects()[0].top;\n    let insIndexBefore = (_c = (_b = dragState.to) === null || _b === void 0 ? void 0 : _b.eventualIndex) !== null && _c !== void 0 ? _c : 0;\n    let updatedNewIndex = insIndexBefore;\n    const { yStartNoMoveZone, yEndNoMoveZone } = (_d = dragState.to) !== null && _d !== void 0 ? _d : {\n        yStartNoMoveZone: Infinity,\n        yEndNoMoveZone: -Infinity,\n    };\n    const { containerEl: fromEl, index: fromIndex, } = dragState.from;\n    const isMove = dragState.dragKind === DragKind.Move;\n    // TODO: Extract, deduplicate, cache.\n    const activeElHeight = dragState.pickedEl.offsetHeight;\n    // Note: placeholderEl may be in a different container, so it's height may\n    // be completely broken here. It shouldn't matter, though, as we won't be\n    // using it in that case.\n    const activeToPlaceholderOffset = dragState.to ? dragState.to.placeholderEl.offsetHeight - activeElHeight : 0;\n    const activeToNothingOffset = -activeElHeight - 8;\n    const nothingToPlaceholderOffset = (_f = (_e = dragState.to) === null || _e === void 0 ? void 0 : _e.placeholderEl.offsetHeight) !== null && _f !== void 0 ? _f : 0;\n    let wiggleZoneSize = 0.5;\n    let snapMargin = (1 - wiggleZoneSize) / 2;\n    let bottomSnapBorder = yDirection === -1 ? (1 - snapMargin) : snapMargin;\n    let startIndex = getItemsInContainerStartIndex(containerEl);\n    let endIndex = getItemsInContainerEndIndex(containerEl);\n    if (ignoreCurrentNewIndex || (mouseY < yStartNoMoveZone && updatedNewIndex !== 0)) {\n        // Correct for the fact that if we dragged the element down from\n        // its place, some elements above it are shifted from their\n        // offset position.\n        let offsetCorrection = containerEl === dragState.from.containerEl && isMove ? activeToNothingOffset : 0;\n        updatedNewIndex = startIndex;\n        // We may look up one extra element at the start, but that is not an issue.\n        let iterationStart = endIndex - 1;\n        if (!ignoreCurrentNewIndex && insIndexBefore < iterationStart) {\n            iterationStart = insIndexBefore;\n        }\n        for (let i = iterationStart; i >= startIndex; --i) {\n            let otherEl = containerEl.children[i];\n            if (otherEl === dragState.pickedEl && isMove)\n                continue;\n            if (i < fromIndex) {\n                // We could check for (toEl === fromEl) here, but the\n                // value is going to be 0 anyway.\n                offsetCorrection = 0;\n            }\n            if (getComputedStyle(otherEl).display === 'none') {\n                continue;\n            }\n            let otherTop = otherEl.offsetTop + offsetCorrection;\n            let otherHeight = otherEl.offsetHeight;\n            if (mouseY > otherTop + bottomSnapBorder * otherHeight) {\n                // Insert activeEl after otherEl.\n                if (containerEl === fromEl && isMove && i > fromIndex) {\n                    // Special new case. otherEl will be moved up\n                    // and end up with index i-1, so inserting after\n                    // it means we will end up with index i.\n                    updatedNewIndex = i;\n                }\n                else {\n                    updatedNewIndex = i + 1;\n                }\n                break;\n            }\n        }\n    }\n    else if (mouseY > yEndNoMoveZone) {\n        let offsetCorrection = nothingToPlaceholderOffset;\n        // Set to the highest possible value - in case we are at the very\n        // bottom of the container.\n        updatedNewIndex = (containerEl === fromEl && isMove) ? endIndex - 1 : endIndex;\n        // We may look up one extra element at the start, but that is not an issue.\n        for (let i = insIndexBefore; i < endIndex; ++i) {\n            let otherEl = containerEl.children[i];\n            if (otherEl === dragState.pickedEl && isMove)\n                continue; // May still happen.\n            if (i > fromIndex && containerEl === fromEl && isMove) {\n                offsetCorrection = activeToPlaceholderOffset;\n            }\n            if (getComputedStyle(otherEl).display === 'none') {\n                continue;\n            }\n            let otherTop = otherEl.offsetTop + offsetCorrection;\n            let otherHeight = otherEl.offsetHeight;\n            if (mouseY < otherTop + bottomSnapBorder * otherHeight) {\n                // Insert activeEl before otherEl.\n                if (containerEl === fromEl && isMove && i > fromIndex) {\n                    // Special new case. otherEl won't be bumped to i+1\n                    // but instead back to i-th position when we\n                    // re-insert activeEl, so the inserting splice\n                    // will be at position i-1, not i.\n                    updatedNewIndex = i - 1;\n                }\n                else {\n                    updatedNewIndex = i;\n                }\n                break;\n            }\n        }\n    }\n    return updatedNewIndex;\n}\nfunction updatePlaceholderAndNoMoveZone(to) {\n    let newPlaceholderTop = findPlaceholderTop(to);\n    // TODO: Extract, deduplicate, cache, correct margins.\n    const nothingToPlaceholderOffset = to.placeholderEl.offsetHeight;\n    to.yStartNoMoveZone = newPlaceholderTop - 8;\n    to.yEndNoMoveZone = newPlaceholderTop - nothingToPlaceholderOffset;\n    to.placeholderEl.style.transform = `translateY(${newPlaceholderTop}px)`;\n}\nfunction findPlaceholderTop({ containerEl: toEl, eventualIndex, }) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    const { containerEl: fromEl, index: oldIndex, } = dragState.from;\n    const isMove = dragState.dragKind === DragKind.Move;\n    // TODO: Extract, deduplicate, cache.\n    const activeElHeight = dragState.pickedEl.offsetHeight;\n    const activeToNothingOffset = -activeElHeight - 8;\n    let startIndex = getItemsInContainerStartIndex(toEl);\n    let endIndex = getItemsInContainerEndIndex(toEl);\n    let ref, offsetCorrection;\n    if (endIndex === startIndex) {\n        // We don't have any reference, it will just be at the top.\n        // However, the offsetCorrection should probably account for\n        // margin/padding.\n        ref = null;\n        offsetCorrection = 0;\n    }\n    else if (toEl === fromEl && isMove && eventualIndex === endIndex - 1) {\n        // Last element in fromEl.\n        ref = toEl.children[endIndex - 1];\n        // Position the placeholder _after_ the ref.\n        offsetCorrection = ref.offsetHeight + 8 + activeToNothingOffset;\n    }\n    else if ((toEl !== fromEl || !isMove) && eventualIndex === endIndex) {\n        // Last element, not in fromEl.\n        ref = toEl.children[endIndex - 1];\n        // Position the placeholder _after_ the ref.\n        offsetCorrection = ref.offsetHeight + 8;\n    }\n    else if (toEl === fromEl && isMove && eventualIndex > oldIndex) {\n        ref = toEl.children[eventualIndex + 1];\n        offsetCorrection = activeToNothingOffset;\n    }\n    else {\n        ref = toEl.children[eventualIndex];\n        offsetCorrection = 0;\n    }\n    // Correct the ref if we hit an element with display: none.\n    // Thanks to endIndex check we know that the ref is either displayed\n    // itself or there is a displayed object below it, that we will eventually\n    // find..\n    while (ref && getComputedStyle(ref).display === 'none') {\n        ref = ref.nextElementSibling;\n    }\n    // This will be the new activeEl's top as well, once we move it.\n    return ref ? ref.offsetTop + offsetCorrection : offsetCorrection;\n}\nfunction stateDrag_window_TouchCancel(event) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    exitDrag(false);\n}\nfunction stateDrag_window_TouchEnd(event) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    dragEndedWithRelease();\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction stateDrag_window_PointerCancel(event) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    exitDrag(false);\n}\nfunction stateDrag_window_PointerUp(event) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    if (event.pointerId !== dragState.pointerId) {\n        // Not relevant.\n        return;\n    }\n    dragEndedWithRelease();\n}\nfunction dragEndedWithRelease() {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    // We can't really prevent the browser for generating a click, but we\n    // can capture it. The click will, however, not necessaily generate\n    // (only when there was an element that browser thinks was clicked), so\n    // we limit blocking to immediately generated events.\n    preventImmediateClick();\n    // End drag successfully, except when we aren't actually in any container.\n    // TODO: Should we have a special handling for touchcancel? OTOH, I don't\n    // see it showing up in practice. Maybe except when touch becomes a scroll,\n    // but we eliminate that instance.\n    exitDrag(Boolean(dragState.to));\n}\nfunction exitDrag(execSort) {\n    var _a;\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PreDrag &&\n        (dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag) {\n        throw new Error(`exitDrag called in wrong state: ${dragState === null || dragState === void 0 ? void 0 : dragState.state}`);\n    }\n    if (execSort && !(dragState.state === StateEnum.PendingDrag && dragState.to)) {\n        console.error('Exit drag called with execSort==true, but conditions are not met.');\n        execSort = false;\n    }\n    if (dragState.state == StateEnum.PendingDrag) {\n        dragState.floatEl.remove(); // Removing this element now saves some special casing.\n        if (dragState.to) {\n            dragState.to.placeholderEl.remove();\n        }\n    }\n    else {\n        clearTimeout(dragState.preDragTimeoutId);\n    }\n    let insertEl = null;\n    let dragEndEvent;\n    // Note: toEl is implied by execSort, but Typescript doesn't know that.\n    if (execSort &&\n        dragState.state === StateEnum.PendingDrag &&\n        dragState.to &&\n        (dragState.to.containerEl !== dragState.from.containerEl ||\n            dragState.to.eventualIndex !== dragState.from.index)) {\n        insertEl = (dragState.dragKind === DragKind.Move) ? dragState.pickedEl : dragState.pickedEl.cloneNode(true);\n        dragEndEvent = {\n            dragExecuted: true,\n            item: dragState.pickedEl,\n            from: dragState.from.containerEl,\n            fromIndex: dragState.from.index,\n            oldIndex: dragState.from.index,\n            to: dragState.to.containerEl,\n            eventualIndex: dragState.to.eventualIndex,\n            insertionIndex: dragState.to.insertionIndex,\n            newIndex: dragState.to.eventualIndex,\n        };\n        // Note:\n        // We need to adjust the position of elements with transform\n        // to avoid shifting them around suddenly. It would be nice\n        // to do that in one go for each element, but that would involve\n        // several cases and so on. I'll just do that as I go, and not\n        // worry that I do that twice for some elements most of the time.\n        if (dragState.dragKind === DragKind.Move) {\n            dragState.pickedEl.remove();\n        }\n        const { containerEl: fromEl, index: fromIndex, } = dragState.from;\n        const { containerEl: toEl, eventualIndex, } = dragState.to;\n        // TODO: Extract, deduplicate, cache.\n        const activeElHeight = dragState.pickedEl.offsetHeight;\n        const activeToNothingOffset = -activeElHeight - 8;\n        // Adjust elements after removed and animate them to 0.\n        for (let elem of Array.from(fromEl.children).slice(fromIndex)) {\n            let currentTransform = (transformsByElem.get(elem) || [0, 0]);\n            currentTransform[1] -= activeToNothingOffset;\n            if (currentTransform[0] !== 0 || currentTransform[1] !== 0) {\n                transformsByElem.set(elem, currentTransform);\n            }\n            Anim.start(fromEl, [elem], 0, animMs, currentTransform[1]);\n        }\n        // Remove placeholder.\n        dragState.to.placeholderEl.remove();\n        // We removed pickedEl before, so now we insert simply at eventualIndex.\n        if (eventualIndex === toEl.children.length) {\n            toEl.appendChild(insertEl);\n        }\n        else {\n            toEl.children[eventualIndex].before(insertEl);\n        }\n        // Adjust elements after inserted and animate them to 0.\n        for (let elem of Array.from(toEl.children).slice(eventualIndex + 1)) {\n            let currentTransform = (transformsByElem.get(elem) || [0, 0]);\n            currentTransform[1] += activeToNothingOffset;\n            if (currentTransform[0] !== 0 || currentTransform[1] !== 0) {\n                transformsByElem.set(elem, currentTransform);\n            }\n            Anim.start(fromEl, [elem], 0, animMs, currentTransform[1]);\n        }\n    }\n    else {\n        dragEndEvent = {\n            dragExecuted: false,\n            item: dragState.pickedEl,\n            from: dragState.from.containerEl,\n            fromIndex: dragState.from.index,\n            oldIndex: dragState.from.index,\n        };\n        // When cancelling, let's simply tell everyone to go home.\n        for (let cont of [dragState.from.containerEl, (_a = dragState.to) === null || _a === void 0 ? void 0 : _a.containerEl]) {\n            if (cont) { // toEl may be missing.\n                Anim.start(cont, Array.from(cont.children), 0, animMs);\n            }\n        }\n    }\n    cancelInvisible(dragState.pickedEl);\n    if (dragState.state == StateEnum.PendingDrag) {\n        let animElem = insertEl !== null && insertEl !== void 0 ? insertEl : dragState.pickedEl;\n        // Our Anim handles only y animation for now, we should fix that.\n        // However, let's at least handle the y.\n        let destRect = animElem.getClientRects()[0];\n        Anim.start(animElem, [animElem], 0, animMs, dragState.floatElPos.y - destRect.top);\n        if (dragState.to) {\n            removeBottomPaddingCorrection(dragState.to.containerEl);\n            // Invoke onContainerLeft here to be consistent with how it's called\n            // in leaveContainer - after the container cleanup.\n            const toContainerOptions = dragState.to.containerEl[expando].options;\n            if (typeof toContainerOptions.onContainerLeft === 'function') {\n                toContainerOptions.onContainerLeft(dragState.to.containerEl, dragState.pickedEl);\n            }\n        }\n    }\n    toggleEvents_statePreDrag(false, dragState.touchDrag);\n    toggleEvents_stateDrag(false, dragState.touchDrag);\n    revertOverscrollBehavior();\n    revertUserSelectOnBody();\n    setDragState(null);\n    // Finally, let call all the drag-end events.\n    // All the callbacks get the same event object.\n    const fromContainerOptions = dragEndEvent.from[expando].options;\n    if (dragEndEvent.dragExecuted) {\n        if (dragEndEvent.to === dragEndEvent.from) {\n            if (typeof fromContainerOptions.onInternalChange === 'function') {\n                fromContainerOptions.onInternalChange(dragEndEvent);\n            }\n        }\n        else {\n            if (typeof fromContainerOptions.onDropToOtherContainer === 'function') {\n                fromContainerOptions.onDropToOtherContainer(dragEndEvent);\n            }\n            const toContainerOptions = dragEndEvent.to[expando].options;\n            if (typeof toContainerOptions.onDropFromOtherContainer === 'function') {\n                toContainerOptions.onDropFromOtherContainer(dragEndEvent);\n            }\n        }\n    }\n    if (typeof fromContainerOptions.onDragFinished === 'function') {\n        fromContainerOptions.onDragFinished(dragEndEvent);\n    }\n}\nfunction anyState_container_PointerEnter(event) {\n    var _a;\n    const containerEl = event.currentTarget;\n    const containerData = containerEl[expando];\n    containerHoverEntered(containerData);\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag) {\n        // Not dragging anything, so nothing to do.\n        return;\n    }\n    if (containerEl === ((_a = dragState.to) === null || _a === void 0 ? void 0 : _a.containerEl)) {\n        // Already in this container, nothing to do.\n        return;\n    }\n    maybeEnterContainer(containerData, event);\n}\nfunction anyState_container_PointerLeave(event) {\n    var _a;\n    const containerEl = event.currentTarget;\n    const containerData = containerEl[expando];\n    containerHoverLeft(containerData);\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag ||\n        containerEl !== ((_a = dragState.to) === null || _a === void 0 ? void 0 : _a.containerEl)) {\n        return; // Not relevant.\n    }\n    // PointerLeave event might have been caused by releasing the touch or\n    // button, however, we can't really tell. event.buttons === 0 works in\n    // most browsers, but not iOS Safari (at least not in 14).\n    // We will instead wait for other related events to dispatch. In case\n    // this is the pointerup case, the drag will be over by the time the timer\n    // executes.\n    setTimeout(() => {\n        var _a;\n        // Make sure that the drag is still pending and we didn't move\n        // to another container. In issue #8 we were hitting toEl === null here,\n        // apparently because several timeouts from several left containers\n        // got clamped together.\n        if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) === StateEnum.PendingDrag &&\n            containerEl === ((_a = dragState.to) === null || _a === void 0 ? void 0 : _a.containerEl)) {\n            leaveContainer();\n            // mousemove handler will figure the container to enter.\n            // TODO: if it gets glitchy, call the mousemove handler here directly.\n        }\n    }, 0);\n}\nfunction maybeEnterContainer(containerData, evPlace) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    let cData = containerData;\n    let rect = cData.el.getClientRects()[0];\n    if (!cData.options.allowDrop || !rect) {\n        return false;\n    }\n    const xLast = dragState.currentPointerPos.x;\n    if (xLast >= rect.left + rect.width * cData.options.enterGuardLeft + cData.options.enterGuardLeftPx &&\n        xLast <= rect.right - rect.width * cData.options.enterGuardRight - cData.options.enterGuardRightPx) {\n        const eventualIndex = findUpdatedEventualIndex(cData.el, evPlace);\n        const insertionIndex = insertionIndexFromEventualIndex(cData.el, eventualIndex);\n        if (!dragState.forbiddenIndices.isForbiddenIndex(cData.el, dragState.pickedEl, insertionIndex)) {\n            enterContainer(cData.el, insertionIndex, eventualIndex);\n            return true;\n        }\n    }\n    return false;\n}\nfunction enterContainer(toEl, insertionIndex, eventualIndex) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    if (dragState.to) {\n        // Handle removal from the previous container.\n        leaveContainer();\n    }\n    // Then handle insertion into the new container.\n    updateScrollers(toEl);\n    dragState.to = {\n        containerEl: toEl,\n        insertionIndex,\n        eventualIndex,\n        placeholderEl: createPlaceholder(toEl),\n        yStartNoMoveZone: 0,\n        yEndNoMoveZone: 0,\n    };\n    addBottomPaddingCorrection();\n    updatePlaceholderAndNoMoveZone(dragState.to);\n    dragState.to.placeholderEl.style.visibility = 'visible';\n    animateMoveInsideContainer(toEl, getItemsInContainerEndIndex(toEl), eventualIndex);\n    const containerOptions = toEl[expando].options;\n    if (typeof containerOptions.onContainerEntered === 'function') {\n        containerOptions.onContainerEntered(dragState.from.containerEl, dragState.pickedEl);\n    }\n}\nfunction leaveContainer() {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    if (!dragState.to) {\n        return;\n    }\n    const leftContainerEl = dragState.to.containerEl;\n    animateMoveInsideContainer(leftContainerEl, dragState.to.eventualIndex, getItemsInContainerEndIndex(leftContainerEl));\n    removeBottomPaddingCorrection(leftContainerEl);\n    dragState.to = undefined;\n    const containerOptions = leftContainerEl[expando].options;\n    if (typeof containerOptions.onContainerLeft === 'function') {\n        containerOptions.onContainerLeft(leftContainerEl, dragState.pickedEl);\n    }\n}\nfunction createPlaceholder(toEl) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    const placeholderEl = document.createElement('div');\n    placeholderEl.style.position = 'absolute';\n    placeholderEl.style.top = '0';\n    placeholderEl.style.zIndex = '1';\n    placeholderEl.style.background = 'lightgray';\n    placeholderEl.style.userSelect = 'none';\n    placeholderEl.style.pointerEvents = 'none';\n    placeholderEl.style.visibility = 'hidden';\n    placeholderEl.classList.add('drag-placeholder');\n    // Note: that may be before or after floatEl. Maybe that is the problem?\n    toEl.appendChild(placeholderEl);\n    // Set the height only if not set externally.\n    let autoHeight = getComputedStyle(placeholderEl).height;\n    if (!autoHeight || autoHeight === '0px') {\n        placeholderEl.style.height = Math.min(dragState.pickedEl.offsetHeight - 16, 200) + 'px';\n    }\n    // TODO: Figure out how to determine these properly. I guess we need to take\n    // the container's clientWidth and make the actual math with margins and\n    // stuff.\n    // For now let's assume that the offsets on activeEl are ok and that\n    // they are the same on both sides.\n    placeholderEl.style.left = dragState.pickedEl.offsetLeft + 'px';\n    placeholderEl.style.right = dragState.pickedEl.offsetLeft + 'px';\n    return placeholderEl;\n}\nfunction addBottomPaddingCorrection() {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    if (dragState.to && dragState.to.containerEl !== dragState.from.containerEl) {\n        const toEl = dragState.to.containerEl;\n        const nothingToPlaceholderOffset = dragState.to.placeholderEl.offsetHeight;\n        toEl.style.paddingBottom =\n            parseFloat(getComputedStyle(toEl).paddingBottom.slice(0, -2)) + nothingToPlaceholderOffset + 'px';\n    }\n}\nfunction removeBottomPaddingCorrection(toEl) {\n    if ((dragState === null || dragState === void 0 ? void 0 : dragState.state) !== StateEnum.PendingDrag)\n        throw new BadStateError(StateEnum.PendingDrag);\n    if (toEl !== dragState.from.containerEl) {\n        toEl.style.paddingBottom = '';\n    }\n}\nfunction createFloatEl(dragState) {\n    const pickedEl = dragState.pickedEl;\n    const floatEl = pickedEl.cloneNode(true);\n    floatEl.style.position = 'fixed';\n    floatEl.style.left = '0';\n    floatEl.style.top = '0';\n    floatEl.style.margin = '0';\n    floatEl.style.zIndex = '10000000';\n    floatEl.style.pointerEvents = 'none';\n    floatEl.style.width = getComputedStyle(pickedEl).width;\n    floatEl.style.height = getComputedStyle(pickedEl).height;\n    const tOrigX = -dragState.floatFromPointerOffset.x;\n    const tOrigY = -dragState.floatFromPointerOffset.y;\n    floatEl.style.transformOrigin = `${tOrigX}px ${tOrigY}px`;\n    const posX = dragState.currentPointerPos.x + dragState.floatFromPointerOffset.x;\n    const posY = dragState.currentPointerPos.y + dragState.floatFromPointerOffset.y;\n    floatEl.style.transform = `translate(${posX}px,${posY}px) scale(${dragState.floatElScale})`;\n    floatEl.classList.add('drag-float-item');\n    // Position fixed is great, but it has limitation: if any ancestor\n    // has transform, perspective, or filter property set other than none,\n    // it becomes the containing block instead of the viewport, and your\n    // perfect plan for positioning gets royally screwed. That is why we\n    // need to put the floatEl directly on document.body.\n    //\n    // We may some day add an option to put it on the container, a counterpart\n    // to Sortable's fallbackOnBody, but for now we just need it outside\n    // and free of any rogue containing block candidates.\n    document.body.appendChild(floatEl);\n    return floatEl;\n}\nexport default {\n    init: initDragContainer,\n    DragKind,\n};\n"],"names":[],"sourceRoot":""}